<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实验一 排序算法比较</title>
    <url>/posts/data-structure/experiment-01/</url>
    <content><![CDATA[<h1 id="实验一-排序算法比较"><a href="#实验一-排序算法比较" class="headerlink" title="实验一 排序算法比较"></a>实验一 排序算法比较</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>探究在一定的软件和硬件条件下数据的储存限制</li>
<li>探究不同的排序算法所需的时间与数据量的关系</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Ubuntu 16.04</li>
<li>CLion 2017.3</li>
<li>I5-7200U</li>
<li>2G RAM</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>创建大小递增的数组，测试出数组的大小上限</li>
<li>分别使用泡排序、选择排序对数据进行排序</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><ol>
<li>依次创建大小为 10000、20000、30000 …的数组，直到程序崩溃</li>
<li>根据上一步实验结果，分别生成 5000、10000、20000、30000、40000、50000、60000、70000、80000、90000、100000、200000、500000、1000000、1500000、2000000 个随机数字，使用冒泡排序、选择排序对这些数字进行排序</li>
</ol>
<h2 id="测试及结果分析"><a href="#测试及结果分析" class="headerlink" title="测试及结果分析"></a>测试及结果分析</h2><h3 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h3><p>使用 C++ 提供的随机数函数生成的数据</p>
<h3 id="结果及分析"><a href="#结果及分析" class="headerlink" title="结果及分析"></a>结果及分析</h3><h4 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h4><p>结果：创建数组的运行截图如下</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-01/task-01/create-array-stack.png" alt="栈上创建数组"></p>
<p>分析：发现当数组大小达到 2090000 后，继续创建更大的数组时程序出现错误，可知当前条件下数组只能达到 2090000 ~ 2100000。</p>
<p>根据资料可知，C++ 中的数组创建在栈内存中，程序所能使用的最大栈内存在不同的环境下的默认值不同，当前环境的默认栈内存为 8192KB。</p>
<p>已知 C++ 中的 int 类型占用 4Byte，计算可得 8192KB 内存可容纳 2097152 个 int 类型数据，与实验所得的 2090000 ~ 2100000 相近，考虑到程序代码及其他变量占用的内存和本实验中数组大小变化的步长，可认为实验结果正确。</p>
<p>若在堆上创建动态数组，可得到如下结果：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-01/task-01/create-array-heap.png" alt="堆上创建数组"></p>
<p>当数组大小达到 438390000 时，程序出错，经计算 438390000 个 int 类型数据大约占 1.6GB，与当前环境下的可用物理内存总数相等。可知，在堆上创建数组时，受到物理内存大小的制约。</p>
<h4 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h4><p>结果：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-01/task-02/sort-result.png" alt="排序结果"></p>
<p>分析可知冒泡排序和选择排序的均为 O(n2)，对实验所得的数据进行分析可得如下拟合图像，二者所需时间均为数据量的二次函数，故可验证理论分析的正确性。</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-01/task-02/figure.png" alt="拟合曲线"></p>
<h3 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h3><p>数据在计算机中的储存是有限制的，直接创建的数组储存在栈中，其大小受到系统的限制。为了储存更多的数据，可在堆上创建动态数组，但是其速度也会降低。从这个结果看，在研究数据结构时，不仅仅要关注数据之间的逻辑结构，还要考虑到数据的储存结构，考虑到计算机的一些限制，这样才能设计出更加合理的程序。</p>
<p>不同的排序算法都可以在理论上分析其复杂度，从而筛选出更优秀的排序算法，达到在一定量的数据时，使用更少的时间对其进行排序。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数据结构</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>实验二 栈</title>
    <url>/posts/data-structure/experiment-02/</url>
    <content><![CDATA[<h1 id="实验二-栈"><a href="#实验二-栈" class="headerlink" title="实验二 栈"></a>实验二 栈</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>理解栈的特点</li>
<li>掌握栈这种结构的算法设计</li>
<li>学会运用栈来储存数据和求解相关问题</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>设计出一个模板栈，测试栈的各种运算</li>
<li>利用模板栈实现一个计算器来计算给定表达式的值</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>根据栈的特点，栈应具有以下属性和功能：</p>
<p>属性：</p>
<ul>
<li>栈的最大容量</li>
<li>栈顶的指针</li>
<li>栈中元素的数量</li>
</ul>
<p>功能：</p>
<ul>
<li>入栈（压栈）</li>
<li>出栈（弹栈）</li>
<li>获取栈顶元素</li>
<li>判断栈是否为空或是否已满</li>
</ul>
<p>本次实验采用 C++ 作为编程语言，可用 C++ 中的模板类来封装栈，以实现储存不同类型的数据。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 的模板知识来编写模板类的代码。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-01/test-stack.png" alt="测试栈结果"></p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>想要计算一个表达式，第一步应该是录入需要的表达式。将表达式录入后，可以将表达式储存在 string 中。对于输入的表达式，考虑到不同的用户的习惯，表达式中是否存在空格是不能确定的，而且用户输入的表达式是否合法也不确定，因此在计算前应将表达式格式化并进行检验，若表达式不合法，应提示用户重新输入。</p>
<p>获取到表达式后，将运算符与运算数分离开，分别储存在两个栈中。对于如何进行计算，若使用优先级的方法，则对应关系将会很复杂，可以换个角度进行思考。</p>
<p>本次实验中只用到了六种运算符（+、-、*、/、(、)）。在扫描格式化后的表达式时，进行以下讨论：</p>
<ol>
<li>先考虑 “(“，若遇到此运算符，应直接压入栈中继续扫描表达式</li>
<li>若遇到 “)”，那么应该将运算符栈中的运算符依次取出进行计算，直到栈顶运算符为 “(“，将 “(“ 弹出并继续扫描表达式</li>
<li>如果是 “+” 或 “-“，那么应考虑栈顶的运算符，如果栈顶运算符为 “(“ 则应该将扫描到的运算符压入栈，如果栈顶运算符为 “+”、”-“、”*”、”/“则应该将栈顶运算符取出并进行计算</li>
<li>如果扫描到的运算符为 “<em>“ 或 “/“，那么应考虑栈顶的运算符，如果栈顶运算符为 “(“、”+”、”-“ 则应该将扫描到的运算符压入栈，如果遇到 “</em>“、”/“ 则应该将栈顶运算符取出并进行计算<br>至此，所有的可能都被讨论完毕。<br>用户输入的表达式中可能含有除法运算，受到 C++ 中的整数除法运算限制，其结果只能为整数，这样会导致计算的结果出错。对此，可以设计一个 Rational 类（有理数类），将用户输入的表达式中的数字使用自己编写的 stringToRational 函数来转换为 Rational 对象，同时重载 Rational 类的 +、-、*、/ 运算符，这样就能将结果保留为分数形式或带有小数点的形式。</li>
</ol>
<h4 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过已有的模板栈和以上设计思路进行编写代码。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-01.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-02.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-03.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-04.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-05.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-06.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-07.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-08.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-09.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-10.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-11.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-12.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-13.png" alt="测试计算器结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-02/task-02/test-calculator-14.png" alt="测试计算器结果"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，掌握了栈的设计方法，体会到了栈的先进后出的特点。利用这一特点实现了简单的计算器。实际上，在解决实际问题时，若某种现象满足先进后出的规律，都可以考虑到使用栈来作为管理数据的方式，在本次实验中，计算表达式时，从左向右扫描表达式根据后面的操作符来计算操作数，未计算的操作数将被放在一边等待计算，明显符合栈的特点，故可以采用栈来解决问题。</p>
<p>在设计计算的方式时，可以从不同的角度来考虑计算的先后顺序，换一种方式，则可能会简化问题。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>计算器</tag>
      </tags>
  </entry>
  <entry>
    <title>实验三 队列</title>
    <url>/posts/data-structure/experiment-03/</url>
    <content><![CDATA[<h1 id="实验三-队列"><a href="#实验三-队列" class="headerlink" title="实验三 队列"></a>实验三 队列</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>理解队列的特点</li>
<li>掌握队列这种结构的算法设计</li>
<li>学会运用队列来储存数据和求解相关问题</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>设计出一个模板队列，测试队列的各种运算</li>
<li>利用模板队列打印出杨辉三角形</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>根据队列的特点，队列应具有以下属性和功能：</p>
<p>属性：</p>
<ul>
<li>队列的最大容量</li>
<li>队列头的指针</li>
<li>队列尾的指针</li>
<li>队列中元素的数量</li>
</ul>
<p>功能：</p>
<ul>
<li>进队列</li>
<li>出队列</li>
<li>获取队列头元素</li>
<li>判断队列是否为空或是否已满</li>
</ul>
<p>本次实验采用 C++ 作为编程语言，可用 C++ 中的模板类来封装队列，以实现储存不同类型的数据。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 的模板知识来编写模板类的代码。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-03/task-01/test-queue.png" alt="测试队列结果"></p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>根据杨辉三角形的特点：</p>
<ol>
<li>第 N 行有 N 个数字</li>
<li>每一行的开头和结尾均为 “1”</li>
<li>除了数字 “1” 以外的数字都等于其上方两个数字之和。也就是说，除了 “1” 以外的每一个数字都是由之前的数字计算而来，这样，只需将打印出的数字储存起来，根据由上往下打印的规律，应将数字储存在队列中</li>
</ol>
<h4 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过已有的模板队列和以上设计思路进行编写代码。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-03/task-02/test-triangle.png" alt="测试杨辉三角结果"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，掌握了队列的设计方法，体会到了队列的先进先出的特点。利用这一特点来储存数据，打印出了杨辉三角形。实际上，在解决实际问题时，若某种现象满足先进先出的规律，都可以考虑到使用队列来作为管理数据的方式，在本次实验中，打印数据时，每个被打印的数据都应该被储存起来用于之后计算数字，明显符合队列的特点，故可以采用队列来解决问题。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title>实验四 链栈和链队列</title>
    <url>/posts/data-structure/experiment-04/</url>
    <content><![CDATA[<h1 id="实验四-链栈和链队列"><a href="#实验四-链栈和链队列" class="headerlink" title="实验四 链栈和链队列"></a>实验四 链栈和链队列</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>理解链栈和链队列的特点</li>
<li>掌握链栈和链队列这种结构的算法设计</li>
<li>学会运用链栈和链队列来储存数据和求解相关问题</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>设计出链栈，测试链栈的各种运算</li>
<li>设计出链队列，测试链队列的各种运算</li>
<li>使用模板链栈设计出一个计算器</li>
<li>利用模板链队列打印出杨辉三角形</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>根据栈的特点，栈应具有以下属性和功能：</p>
<p>属性：</p>
<ul>
<li>栈顶的指针</li>
<li>栈中元素的数量</li>
</ul>
<p>功能：</p>
<ul>
<li>入栈</li>
<li>出栈</li>
<li>获取栈顶元素</li>
<li>判断栈是否为空</li>
</ul>
<p>本次实验采用 C++ 作为编程语言，可用 C++ 中的模板类来封装栈，以实现储存不同类型的数据。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 的模板知识来编写模板类的代码。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>通过测试，各种功能均正常。</p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>根据链队列的特点，链队列应具有以下属性和功能：</p>
<p>属性：</p>
<ul>
<li>队列头的指针</li>
<li>队列尾的指针</li>
<li>队列中元素的数量</li>
</ul>
<p>功能：</p>
<ul>
<li>进入队列</li>
<li>移出队列</li>
<li>获取队头元素</li>
<li>判断队列是否为空</li>
</ul>
<h4 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 的模板知识来编写模板类的代码。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>通过测试，各种功能均正常。</p>
<h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><h4 id="设计-2"><a href="#设计-2" class="headerlink" title="设计"></a>设计</h4><p>想要计算一个表达式，第一步应该是录入需要的表达式。将表达式录入后，可以将表达式储存在 string 中。对于输入的表达式，考虑到不同的用户的习惯，表达式中是否存在空格是不能确定的，而且用户输入的表达式是否合法也不确定，因此在计算前应将表达式格式化并进行检验，若表达式不合法，应提示用户重新输入。</p>
<p>获取到表达式后，将运算符与运算数分离开，分别储存在两个栈中。对于如何进行计算，若使用优先级的方法，则对应关系将会很复杂，可以换个角度进行思考。</p>
<p>本次实验中只用到了六种运算符（+、-、*、/、(、)）。在扫描格式化后的表达式时，进行以下讨论：</p>
<ol>
<li>先考虑 “(“，若遇到此运算符，应直接压入栈中继续扫描表达式</li>
<li>若遇到 “)”，那么应该将运算符栈中的运算符依次取出进行计算，直到栈顶运算符为 “(“，将 “(“ 弹出并继续扫描表达式</li>
<li>如果是 “+” 或 “-“，那么应考虑栈顶的运算符，如果栈顶运算符为 “(“ 则应该将扫描到的运算符压入栈，如果栈顶运算符为 “+”、”-“、”*”、”/“则应该将栈顶运算符取出并进行计算</li>
<li>如果扫描到的运算符为 “<em>“ 或 “/“，那么应考虑栈顶的运算符，如果栈顶运算符为 “(“、”+”、”-“ 则应该将扫描到的运算符压入栈，如果遇到 “</em>“、”/“ 则应该将栈顶运算符取出并进行计算<br>至此，所有的可能都被讨论完毕。<br>用户输入的表达式中可能含有除法运算，受到 C++ 中的整数除法运算限制，其结果只能为整数，这样会导致计算的结果出错。对此，可以设计一个 Rational 类（有理数类），将用户输入的表达式中的数字使用自己编写的 stringToRational 函数来转换为 Rational 对象，同时重载 Rational 类的 +、-、*、/ 运算符，这样就能将结果保留为分数形式或带有小数点的形式。</li>
</ol>
<h4 id="编码实现-2"><a href="#编码实现-2" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过已有的模板栈和以上设计思路进行编写代码。</p>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>经过测试，所有功能均正常。</p>
<h3 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h3><h4 id="设计-3"><a href="#设计-3" class="headerlink" title="设计"></a>设计</h4><p>根据杨辉三角形的特点：</p>
<ol>
<li>第 N 行有 N 个数字</li>
<li>每一行的开头和结尾均为 “1”</li>
<li>除了数字 “1” 以外的数字都等于其上方两个数字之和。也就是说，除了 “1” 以外的每一个数字都是由之前的数字计算而来，这样，只需将打印出的数字储存起来，根据由上往下打印的规律，应将数字储存在队列中</li>
</ol>
<h4 id="编码实现-3"><a href="#编码实现-3" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过已有的模板队列和以上设计思路进行编写代码。</p>
<h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>经过测试，所有功能均正常。</p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，掌握了栈的设计方法，体会到了栈的先进后出的特点。利用这一特点实现了简单的计算器。实际上，在解决实际问题时，若某种现象满足先进后出的规律，都可以考虑到使用栈来作为管理数据的方式，在本次实验中，计算表达式时，从左向右扫描表达式根据后面的操作符来计算操作数，未计算的操作数将被放在一边等待计算，明显符合栈的特点，故可以采用栈来解决问题。</p>
<p>掌握了链栈和链队列的设计方法，体会到了队列的先进先出的特点<br>利用这一特点来储存数据，打印出了杨辉三角形。实际上，在解决实际问题时，若某种现象满足先进先出的规律，都可以考虑到使用队列来作为管理数据的方式。在本次实验中，打印数据时，每个被打印的数据都应该被储存起来用于之后计算数字，明显符合队列的特点，故可以采用队列来解决问题。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>计算器</tag>
        <tag>杨辉三角</tag>
        <tag>链栈</tag>
        <tag>链队列</tag>
      </tags>
  </entry>
  <entry>
    <title>实验五 链表</title>
    <url>/posts/data-structure/experiment-05/</url>
    <content><![CDATA[<h1 id="实验五-链表"><a href="#实验五-链表" class="headerlink" title="实验五 链表"></a>实验五 链表</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>理解顺序表和链表的特点</li>
<li>掌握顺序表和链表这两种结构的算法设计</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>设计出一个模板顺序表和模板链表，测试线性表的各种运算</li>
<li>将两个线性表使用不同的算法进行合并  </li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>链表应提供一个初始化表的运算，根据 C++ 的类的特性，可以使用构造函数来实现，在创建链表对象时，对链表进行初始化。</p>
<p>为了能储存数据，链表还应提供一个插入运算，可以将数据插入到指定的位置，与此对应还应提供一个删除元素的运算。</p>
<p>此外，还可以添加一些辅助功能，如判断链表是否为空、在表中查找元素，获取表中指定位置的元素，合并两个表。</p>
<p>根据链表的特点，链表应具有以下属性和运算：</p>
<p>属性：</p>
<ul>
<li>int count;</li>
<li>node<elementType>* head;</li>
</ul>
<p>运算：</p>
<ul>
<li>linkedList();</li>
<li>~linkedList();</li>
<li>bool insert(int index, const elementType&amp; x);</li>
<li>bool deleteElement(int index);</li>
<li>bool empty();</li>
<li>bool getElement(int index, elementType&amp;);</li>
<li>node<elementType>* getElement(int index);</li>
<li>node<elementType>* locate(const elementType&amp;);</li>
<li>void ascendingSort();</li>
<li>void mergeList(const linkedList&amp;, linkedList&amp;);</li>
<li>void ascendingMergeList(const linkedList&amp;, linkedList&amp;);</li>
<li>void show();</li>
<li>int length();</li>
</ul>
<p>比较顺序表和链表的特点可知，二者采用的储存结构不同，但是应提供相同的接口来对外提供服务。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 的模板知识来编写模板类的代码。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试各种运算均正常。</p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>将两个表合并为一个有序表，根据分析可知，有两种顺序：</p>
<ul>
<li>先将两个表进行合并，对合并后的表进行排序</li>
<li>先对两个表进行排序，然后再进行合并</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>实验六 递归</title>
    <url>/posts/data-structure/experiment-06/</url>
    <content><![CDATA[<h1 id="实验六-递归"><a href="#实验六-递归" class="headerlink" title="实验六 递归"></a>实验六 递归</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>学会使用递归的方法来解决问题</li>
<li>掌握递归程序改为非递归程序的方法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>写出递归版本的斐波那契数列</li>
<li>将任务一中的代码改造为非递归版本</li>
<li>将任务二中的代码进一步简化，消去 goto</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>由函数 F[n] = F[n-1] + F[n-2] (n &gt; 2, F[0] = 1, F[1] = 1)，可知斐波那契数列是递归定义的，即斐波那契数列中的第 n 项（n &gt; 1）是由其前面两项来确定的。根据这个特性不难写出代码。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>编码实现，通过 C++ 来实现以上分析过程。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-06/fibo-01.png" alt="斐波那契数列-递归版本"></p>
<p>代码符合要求。</p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成 3 件事:</p>
<ol>
<li>将所有的实在参数、返回地址等信息传递给被调用函数保存</li>
<li>为被调用函数的局部变量分配存储区</li>
<li>将控制转移到被调函数的人口。</li>
</ol>
<p>而从被调用函数返回调用函数之前，系统也应完成 3 件工作:</p>
<ol>
<li>保存被调函数的计算结果</li>
<li>释放被调函数的数据区</li>
<li>依照被调函数保存的返回地址将控制转移到调用函数。</li>
</ol>
<p>当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现,即系统将整个程序运行时所需的数据空间安排在一个栈中,每当调用一个函数时,就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。</p>
<p>另外通过资料可知有一种特殊的递归——尾递归，即在函数的最后对自身进行调用。这种调用形式导致其具有特殊的性质：尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。因此就不需要进行一系列的压栈、出栈等操作，改为非递归版本时也会简单的多。</p>
<p>通过改造可将代码改为尾递归，进而改造为非递归版本。</p>
<h4 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 进行编写代码。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-06/fibo-02.png" alt="斐波那契数列-非递归版本"></p>
<h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><h4 id="设计-2"><a href="#设计-2" class="headerlink" title="设计"></a>设计</h4><p>通过任务二中的代码不难画出程序执行的流程图，从而分析出简化版本。</p>
<h4 id="编码实现-2"><a href="#编码实现-2" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 进行编写代码。</p>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-06/fibo-03.png" alt="斐波那契数列-非递归改进版本"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，学会使用递归的方法来解决问题，掌握递归程序改为非递归程序的方法。</p>
<p>递归是程序设计中的一个强有力的工具。其一，有很多数学函数是递归定义的；其二，有的数据结构，如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述;其三，还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比迭代求解更简单,如八皇后问题、Hanoi 塔问题等。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>实验七 二叉树</title>
    <url>/posts/data-structure/experiment-07/</url>
    <content><![CDATA[<h1 id="实验七-二叉树"><a href="#实验七-二叉树" class="headerlink" title="实验七 二叉树"></a>实验七 二叉树</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>掌握二叉树的特点和性质 </li>
<li>掌握求取二叉树深度的方法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>利用给定数据构造二叉树，并将其遍历</li>
<li>使用三种不同的方式求取二叉树的深度</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>二叉树中的每个节点都可能具有左孩子和右孩子且需要存放数据，可以定义一个结构体来表示每一个节点。</p>
<p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。</p>
<p>由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。考虑到二叉树本身就具有递归定义的特点——每个节点的子树又构成一颗二叉树，故而可以采用递归的方式来遍历二叉树，先访问根节点然后再遍历左、右子树。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>编码实现，通过 C++ 来实现以上分析过程。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-07/bi-tree.png" alt="二叉树"></p>
<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，当前树的高度即为左、右子树的高度中较大的一个再加 1，递归的出口就是节点为空。</p>
<p>利用层次遍历的算法，设置变量 depth 记录当前节点所在的层数，当遍历完层后，depth 自增一次。可以采用两个队列来存放当前层的节点和下一层的节点，这样即可分辨当前层的节点是否遍历完成。</p>
<p>利用递归遍历的算法，设置 depth 表示当前的深度，maxDepth 表示最大深度，访问子节点时 depth 自增，若 depth 大于 maxDepth，则 maxDepth 自增，从子节点返回父节点时， depth 自减，访问完每个节点后，即可得到二叉树的深度</p>
<h4 id="编码实现-1"><a href="#编码实现-1" class="headerlink" title="编码实现"></a>编码实现</h4><p>通过 C++ 进行编写代码。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>三种算法均可正确求出二叉树的深度</p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，掌握了构造二叉树的方法，二叉树的递归特性有了更进一步的理解。尤其是在遍历二叉树时，利用二叉树的递归特性，可以写出非常简洁的递归算法。</p>
<p>在求二叉树的深度时，可以采用分治的方法，将整个二叉树的深度问题分解为许多子树的深度问题，最后再合并，可以说该算法非常简单明了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>实验八 线索二叉树</title>
    <url>/posts/data-structure/experiment-08/</url>
    <content><![CDATA[<h1 id="实验八-线索二叉树"><a href="#实验八-线索二叉树" class="headerlink" title="实验八 线索二叉树"></a>实验八 线索二叉树</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>掌握线索二叉树的特点和性质 </li>
<li>掌握将二叉树线索化的方法</li>
<li>掌握遍历线索二叉树的方法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>利用给定数据构造二叉树，并将其后序线索化</li>
<li>遍历后序线索化的二叉树</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>可以将二叉树节点中的空指针改为指向其在后序遍历中的前驱和后继，所以只需在后序递归遍历二叉树时，将访问节点的操作更改为设置左右线索即可。同时，为了区分左右孩子指针和前后线索指针可以设置 tag 标记来区分。</p>
<p>在后序线索树中找结点后继较复杂些，可分3种情况：</p>
<ol>
<li>若结点 x 是二叉树的根，则其后继为空</li>
<li>若结点又是其双亲的右孩子或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点</li>
<li>若结点 x 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点</li>
</ol>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>编码实现，通过 C++ 来实现以上分析过程。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-08/thread-tree.png" alt="线索二叉树"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，掌握了构造线索二叉树的方法。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>实验九 森林</title>
    <url>/posts/data-structure/experiment-09/</url>
    <content><![CDATA[<h1 id="实验九-森林"><a href="#实验九-森林" class="headerlink" title="实验九 森林"></a>实验九 森林</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>掌握树和森林线索点和性质 </li>
<li>掌握将森林改为二叉树的方法</li>
<li>掌握求森林深度的方法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>利用给定数据森林，并将其改为二叉树</li>
<li>求森林的深度</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>由前面的存储结构可知，若要将森林转换为二叉树，需进行这样的转换：对森林中的每个结点，用一个二叉树结点来对应，并将二义树结点的片边指针指向其第一个孩子(作为左孩子形式)，右边指针指向其下一个兄弟(作为右孩子形式)，将森林中各棵树的根当做兄弟来转换,如果森林用有序表 F = (T1, T2, …, T) 来表示，则将森林F转换为对应的二叉树 BT 的形式化描述如下。</p>
<p>如果 m = 0,则 BT 为空；否则依次做如下操作：</p>
<ol>
<li>将 T 的根结点作为 BT 的根</li>
<li>将 T 的子树森林转换为 BT 的左子树</li>
<li>将(T2, T3,…, T)转换为BT的右子树</li>
</ol>
<p>由描述可知，转换过程可分 3 部分，即根、子树和兄弟森林，而子树和兄弟森林的求解与原题求解类似。</p>
<p>在求树的深度时，可以参考二叉树求深度的方法，不同的是在新的二叉树中，遇到左孩子才需要将深度增加。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>编码实现，通过 C++ 来实现以上分析过程。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-09/forest.png" alt="森林转为二叉树"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验掌握树和森林线索点和性质，掌握将森林改为二叉树的方法，掌握求森林深度的方法。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>森林</tag>
      </tags>
  </entry>
  <entry>
    <title>实验十 哈夫曼树</title>
    <url>/posts/data-structure/experiment-10/</url>
    <content><![CDATA[<h1 id="实验十-哈夫曼树"><a href="#实验十-哈夫曼树" class="headerlink" title="实验十 哈夫曼树"></a>实验十 哈夫曼树</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>掌握哈夫曼树的特点和性质</li>
<li>掌握构造哈夫曼树的方法</li>
<li>掌握产生哈夫曼编码的方法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>利用哈夫曼树设计并实现一个解压缩程序</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>常规情况下，一个系统中字符的内部编码是等长的，如西文字符的长度是 8 位(bit)，汉字的编码长度是 16 位。在这种情况下，无压缩可言。</p>
<p>然而，如果给各字符的编码不等长，并使高频字符编码长度更短一些，则可实现压缩。压缩的方法可借助于哈夫曼树来实现求解。</p>
<p>首先，将所给出的各字符的个数作为权值来构造一棵哈夫曼树，然后对此哈夫曼树编码就可以得到哈夫曼编码，这些编码就可以作为各字符的新编码。具体求解方法如下：</p>
<ol>
<li>以所给出的数据集 {3, 4, 8, 10, 16, 18, 20, 21}所构造的哈夫曼树。</li>
<li>设根结点的编码为空，然后从根结点开始依次对各结点按如下方法编码:</li>
</ol>
<ul>
<li>每个结点的左孩子的编码通过在其父结点的编码后添加二进制 0 而得到，而每个结点的右孩子的编码通过在其父结点的编码后添加二进制 1 而得到。</li>
</ul>
<ol start="3">
<li>新文件的长度。将各叶子结点所对应的编码作为对应字符的新编码可节省存储空间。其中出现个数为 3 的字符的编码为 0000 出现个数为 4 的字符的编码为 0001 等。依照这一方法来编码，可知重新编码的文件的长度为各字符的个数乘以其长度之积的和，也即为哈夫曼树的带权路径长度的值：(3 + 4) x 5 + 8 x 4 + (10 + 16 + 18) x 3 + (20 + 21) x 2 = 281，也就是说，在对文件中的字符按新的编码存储时，100 个字符所占用的位数共有 281 位。如果采用等长方式，则这 8 个字符中的每个字符都需要 3 位，因而共需要 300 位。由此可知，这一不等长编码能节省存储空间。如果字符数目较多，并且其频度有较大的差异，则其压缩程度会更明显。按照这方法，可设计出对文件进行压缩的程序．</li>
</ol>
<p>根据哈夫曼树的特点，权重越大的叶子距离树根越近．为了压缩文件，可以对文件进行扫描，如果一次扫描一个字节，那么节点的种类最多为 2 的 8 次方，即 256 种，扫描完成后即可统计出各种节点的出现次数．根据统计结果建立哈夫曼树，即可得到按每种字节出现的次数为权重的哈夫曼树。压缩文件的方法就是，利用生成的哈夫曼树，对出现次数更多的字节进行重新编码，用更短的二进制位来替换原先的字节（8 位）。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>编码实现，通过 C++ 来实现以上分析过程。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>图中 9.txt 为源文件，9.txt.compress 为压缩后的文件，9.txt.compress.uncompress 是解压后的文件。可以看出文件被压缩了 0.7MB，解压后的文件的 MD5 值与压缩前的文件相同。所以解压缩的目的均已达到。</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-10/compress.png" alt="压缩/解压效果图"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验掌握了哈夫曼树的特点和性质，掌握了构造哈夫曼树并且生成哈夫曼编码的方法。</p>
<p>在编写解压缩软件的过程对哈夫曼树的结构有了更进一步的了解。</p>
<p>在对压缩结果分析时，我发现对于一些文本文件的压缩效果非常好，而对非文本文件进行测试时发现压缩效果非常小，甚至不压缩。进一步分析这些文件，根据对各种节点出现次数的统计结果发现，这些文件的节点分布非常均匀，各种节点出现次数差异不大，根据哈夫曼树的特点可知，对于该种文件是进行不了很好的压缩的。</p>
<p>由此看来，哈夫曼编码更适合压缩文件中分布差距较大的文件，不同的文件应采用不同的方法来应对才能取得更好的效果。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title>实验十一 拓扑排序</title>
    <url>/posts/data-structure/experiment-11/</url>
    <content><![CDATA[<h1 id="实验十一-拓扑排序"><a href="#实验十一-拓扑排序" class="headerlink" title="实验十一 拓扑排序"></a>实验十一 拓扑排序</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>掌握拓扑排序的方法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>输出一个有向无环图的全部拓扑排序序列</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>下面讨论拓扑排序方法的实现。</p>
<ol>
<li>由于求解方法中涉及“入度”，因而需要保存各顶点的入度，为此，不妨采用一个入度数组 ind。为简便起见，假设 ind 中各元素值已经设置好了。</li>
<li>为实现操作拓扑排序 1 中的“找出入度为 0 的顶点”的操作，有两种典型的方法:</li>
</ol>
<ul>
<li>在 ind 数组中搜索。这种方法不理想，一方面要花费较多的搜索时间，另方面还要区分顶点是否已经被输出。</li>
<li>将入度为 0 并且未输出的顶点放在一个结构中，需要时就直接从中取出，而不必搜索，从而节省搜索时间。这样，当出现新的入度为 0 的顶点时，就需要将其存放进来。</li>
</ul>
<ol start="3">
<li>操作拓扑排序 2 中“删除”顶点的实现。有些初学者看到这一操作描述便想着如何在在储结构上实现删除顶点的操作，这不方便，同时也没有必要。完整分析拓扑排序的方法可发现，确定一个顶点是否能被输出的条件是其人度是否为 0，“删除顶点”的目的并非是真的要将其去掉，其真实目的是为了使其后继顶点少一个前驱(即入度减 1)。由此可知，删除顶点的实现可通过将其所有后继顶点的入度减 1 来实现。 </li>
</ol>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>编码实现，通过 C++ 来实现以上分析过程。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>以下是测试结果：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-11/topu.png" alt="压缩/解压效果图"></p>
<h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验掌握了拓扑排序的方法。本次实验实现拓扑排序的过程中借鉴了 DFS 的思想，因此，同时也对 DFS 有了更深的理解。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>实验十二 排序算法</title>
    <url>/posts/data-structure/experiment-12/</url>
    <content><![CDATA[<h1 id="实验十二-排序算法"><a href="#实验十二-排序算法" class="headerlink" title="实验十二 排序算法"></a>实验十二 排序算法</h1><h2 id="实验目的和要求"><a href="#实验目的和要求" class="headerlink" title="实验目的和要求"></a>实验目的和要求</h2><ol>
<li>掌握六种排序算法</li>
<li>理解不同的数据对排序算法</li>
</ol>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol>
<li>Visual Studio 2017 Community</li>
<li>Windows 10 Pro</li>
</ol>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>分析插入排序、选择排序、冒泡排序、希尔排序、快速排序、基数排序的性能</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度 O(n ^ 2), 空间复杂度 O(1)</p>
<p>排序时间与输入有关：</p>
<ul>
<li>输入的元素个数</li>
<li>元素已排序的程度</li>
</ul>
<p>最佳情况，输入数组是已经排好序的数组，运行时间是 n 的线性函数；最坏情况，输入数组是逆序，运行时间是 n 的二次函数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i - <span class="number">1</span>] &gt; num[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; num[j - <span class="number">1</span>] &gt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                num[j] = num[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            num[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度 O(n ^ 2), 空间复杂度 O(1)</p>
<p>排序时间与输入无关，最佳情况，最坏情况都是如此, 不稳定，如 {5, 5, 2}。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> currentMinIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        currentMinIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; ++j)</span><br><span class="line">            <span class="keyword">if</span> (num[currentMinIndex] &gt; num[j])</span><br><span class="line">                currentMinIndex = j;</span><br><span class="line">        <span class="keyword">if</span> (currentMinIndex != i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = num[currentMinIndex];</span><br><span class="line">            num[currentMinIndex] = num[i];</span><br><span class="line">            num[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度 O(n ^ 2), 空间复杂度 O(1)</p>
<p>排序时间与输入无关，最好、最差、平均都是 O(n ^ 2)；稳定，因为是两两比较，不存在跳跃。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt; num[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = num[j];</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">                num[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图中横轴为数据量，纵轴为时间(ms)：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-12/sort-01.jpg" alt="排序对比图 - 1"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度 O(nlogn)，空间复杂度O(logn)；不稳定</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    temp = num[left];</span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (num[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (num[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            t = num[i];</span><br><span class="line">            num[i] = num[j];</span><br><span class="line">            num[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num[left] = num[i];</span><br><span class="line">    num[i] = temp;</span><br><span class="line">    <span class="built_in">quickSort</span>(num, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(num, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度 O(n ^ 1.25)</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> temp = num[j];</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt; num[j - gap])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; num[j - gap])</span><br><span class="line">                &#123;</span><br><span class="line">                    num[j] = num[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                num[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度 O (n)</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* tmp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">int</span>* count = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">maxbit</span>(num, length);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = num[i] / r;</span><br><span class="line">            <span class="keyword">int</span> q = k % <span class="number">10</span>;</span><br><span class="line">            count[q]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = num[j] / r;</span><br><span class="line">            <span class="keyword">int</span> s = p % <span class="number">10</span>;</span><br><span class="line">            tmp[count[s] - <span class="number">1</span>] = num[j];</span><br><span class="line">            count[s]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        r = r * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图中横轴为数据量，纵轴为时间(ms)：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/data-structure/experiment-12/sort-02.jpg" alt="排序对比图 - 2"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>排序算法</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>快速排序</tag>
        <tag>基数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 gulp 压缩静态资源</title>
    <url>/posts/hexo/compress-with-gulp/</url>
    <content><![CDATA[<h1 id="使用-gulp-压缩静态资源"><a href="#使用-gulp-压缩静态资源" class="headerlink" title="使用 gulp 压缩静态资源"></a>使用 gulp 压缩静态资源</h1><p>今天打开浏览器的控制台查看加载耗时的时候，发现 hexo 生成的资源文件都是没有经过压缩的。像下面这个样子：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/hexo/compress-with-gulp/before-compress-html.png" alt="压缩前-HTML"></p>
<p>CSS 和 JavaScript 文件都没有被压缩，我就不贴图了。我们可以使用 gulp 来压缩这些静态资源，提高网站的加载速度。</p>
<p>下面我先直接说说成功的安装步骤，最后再说说遇到的一些坑。</p>
<span id="more"></span>

<h2 id="安装-gulp"><a href="#安装-gulp" class="headerlink" title="安装 gulp"></a>安装 gulp</h2><p>首先要全局安装 gulp:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g gulp</span><br></pre></td></tr></table></figure>

<p>然后在项目中安装以下依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部分 JavaScript 文件需要 Babel</span></span><br><span class="line">yarn add gulp-babel @babel/core babel-preset-env</span><br></pre></td></tr></table></figure>

<h2 id="配置-gulp"><a href="#配置-gulp" class="headerlink" title="配置 gulp"></a>配置 gulp</h2><p>然后在项目的根目录创建 <code>gulpfile.js</code> 文件，写入以下内容：</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlclean&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 HTML 文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyURLs</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 CSS 文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 Javascript 文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">&#x27;./public/**/*.js&#x27;</span>,<span class="string">&#x27;!./public/**/*.min.js&#x27;</span>])</span><br><span class="line">        .pipe(babel(&#123; <span class="attr">presets</span>: [<span class="string">&#x27;env&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, gulp.parallel(<span class="string">&#x27;minify-html&#x27;</span>,<span class="string">&#x27;minify-css&#x27;</span>,<span class="string">&#x27;minify-js&#x27;</span>));</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>只需要在使用 hexo 生成和部署博客的步骤中间加入压缩就可以了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">gulp</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>推荐在 <code>package.json</code> 中加入快捷的运行方式（注意是添加一行命令，不需要把之前存在的内容删掉）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;d&quot;</span>: <span class="string">&quot;hexo generate &amp;&amp; gulp &amp;&amp; hexo deploy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后每次部署时，直接使用以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用 npm</span></span><br><span class="line">npm run d</span><br></pre></td></tr></table></figure>

<h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/hexo/compress-with-gulp/after-compress-html.png" alt="压缩后-HTML"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/hexo/compress-with-gulp/after-compress-css.png" alt="压缩后-CSS"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/hexo/compress-with-gulp/after-compress-js.png" alt="压缩后-JavaScript"></p>
<h2 id="一些坑点"><a href="#一些坑点" class="headerlink" title="一些坑点"></a>一些坑点</h2><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>上面的配置中我并没有启用图片压缩，因为我在安装依赖 <code>gulp-imagemin</code> 的时候一直报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning Error running install script for optional dependency: &quot;C:\\some-dir\\gulp-img\\node_modules\\gifsicle: Command failed.</span><br><span class="line">Exit code: 1</span><br><span class="line">Command: node lib/install.js</span><br><span class="line">Arguments:</span><br><span class="line">Directory: C:\\some-dir\\gulp-img\\node_modules\\gifsicle</span><br><span class="line">Output:</span><br><span class="line">‼ getaddrinfo ENOENT raw.githubusercontent.com</span><br><span class="line">  ‼ gifsicle pre-build test failed</span><br><span class="line">  i compiling from source</span><br><span class="line">  × Error: Command failed: C:\\Windows\\system32\\cmd.exe /s /c \&quot;autoreconf -ivf\&quot;</span><br></pre></td></tr></table></figure>

<p>我尝试了很多方法，包括使用代理，但是还是没有安装成功（可能是我代理没配置好？</p>
<p>但是我的博客上的图片都是单独放在图床上的，所以生成的静态资源基本没有什么图片，因此也就跳过这一项了。</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>细心的同学可能也发现了我在上面的配置中使用了 <code>gulp-babel</code>。我一开始是没有配置 babel 的，但是在压缩 JavaScript 文件时一直报错，仔细看了一下，报错信息是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[10:39:47] Starting &#x27;minify-js&#x27;...</span><br><span class="line">[10:39:48] &#x27;minify-js&#x27; errored after 552 ms</span><br><span class="line">[10:39:48] GulpUglifyError: unable to minify JavaScript</span><br><span class="line">Caused by: SyntaxError: Unexpected token: punc «)»</span><br><span class="line">File: C:\some-dir\blog.xuewen.me\public\js\algolia-search.js</span><br><span class="line">Line: 3</span><br><span class="line">Col: 45</span><br></pre></td></tr></table></figure>

<p>对应的 JavaScript 文件内容是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* global instantsearch, CONFIG */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> algoliaSettings = CONFIG.algolia;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> search = instantsearch(&#123;</span><br><span class="line">    <span class="attr">appId</span>         : algoliaSettings.appID,</span><br><span class="line">    <span class="attr">apiKey</span>        : algoliaSettings.apiKey,</span><br><span class="line">    <span class="attr">indexName</span>     : algoliaSettings.indexName,</span><br><span class="line">    <span class="attr">searchFunction</span>: <span class="function"><span class="params">helper</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> searchInput = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#search-input input&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (searchInput.value) &#123;</span><br><span class="line">        helper.search();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 省略其他代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个文件第 3 行有一个箭头函数，看来 <code>gulp-uglify</code> 不能很好地支持这些特性，因此我使用了 babel 来转换一下再压缩。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/posts/java/annotation/</url>
    <content><![CDATA[<h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>Java 中的<code>注解类型</code> (Annotation Types，下称注解)可以理解成是对代码的一种特殊标记，我们可以把注解标记在类、方法、变量、参数等 Java 元素上。这个标记可以给编写代码的人看，但是它主要还是提供给程序本身进行解析。</p>
<p>也就是说，注解本身其实不能起到作用，还需要其他程序去主动解析注解来采取相应的动作。如果没有相应的解析代码，那么注解就起不到任何作用。</p>
<span id="more"></span>

<h1 id="如何定义一个注解"><a href="#如何定义一个注解" class="headerlink" title="如何定义一个注解"></a>如何定义一个注解</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解其实就是一种新的特殊的接口类型，为了和普通的接口区分开，在定义注解时需要在关键字 <code>interface</code> 前添加 <code>@</code> 符号，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，我们定义的每一个注解都会自动实现 <code>java.lang.annotation.Annotation</code> 接口。</p>
<h2 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h2><p>我们还可以在注解中添加一些 <code>注解类型元素</code> (Annotation Type Elements，下称注解元素)。只需要在注解的实现部分添加一些方法声明 (method declarations)，这些方法就会被定义成注解元素。</p>
<p>但是这些方法声明中<strong>不能</strong>包含形式参数、类型参数、抛出异常 (throws clause)，方法<strong>也不能</strong>被 defalut、static、private、protected 等修饰，<strong>只能</strong>使用 public (不写则默认为 public)。</p>
<p>另外，这些声明的方法的返回值类型，只能是以下几种：</p>
<ul>
<li>原始数据类型</li>
<li>字符串</li>
<li>类</li>
<li>枚举类型</li>
<li>注解类型</li>
<li>以上类型的一维数组</li>
</ul>
<p>例如：</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              点击折叠/展开
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Level</span> </span>&#123;BAD, INDIFFERENT, GOOD&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 原始数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字数串数组</span></span><br><span class="line">    String[] names();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类</span></span><br><span class="line">    <span class="function">Class&lt;User&gt; <span class="title">userClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类型</span></span><br><span class="line">    <span class="function">Level <span class="title">level</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 不能使用包装类型</span></span><br><span class="line">    <span class="function">Integer <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能使用自定义类型</span></span><br><span class="line">    <span class="function">User <span class="title">user</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能使用二维数组</span></span><br><span class="line">    String[][] names();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能包含形式参数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">number</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能抛出异常</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能标记为静态</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能标记为 default</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<p>我们还可以为注解元素指定默认值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><p>根据注解中的注解元素个数，还可以将注解分为：</p>
<ul>
<li>标记注解：注解中不含有注解元素</li>
<li>单元素注解：注解中只有一个注解元素</li>
<li>普通注解：注解中含有超过一个注解元素</li>
</ul>
<p>其中，我们约定单元素注解中的元素统一命名为 <code>value</code>，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是用来修饰注解的注解，经常用到的有：</p>
<ul>
<li>Target</li>
<li>Retention</li>
<li>Inherited</li>
<li>Document</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>这个元注解被用来说明某个注解可以用来修饰什么 Java 元素，声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的取值范围被定义在枚举类 <code>ElementType</code> 中：</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              点击折叠/展开
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    <span class="comment">// 类、接口、枚举</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    <span class="comment">// 形式参数</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    <span class="comment">// 注解</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    <span class="comment">// 包</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Use of a type</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

TODO  最后两个我还看不懂是什么意思

<p>在 @Target 注解本身就使用了 <code>@Target(ElementType.ANNOTATION_TYPE)</code>，说明 @Target 注解只能用来修饰注解。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>这个注解用来说明某个注解的存活时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的取值范围被定义在枚举类 <code>RetentionPolicy</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     * 注解会被编译器丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     * 注解会被编译器保存到 .class 文件中，但是不会被 JVM 保留到运行期间。这是默认的取值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注解会被保留到运行时，可以通过反射读取到。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>这个注解用来表示某个注解在类继承的时候，父类上的注解是否可以被子类继承到。</p>
<p>这个注解只是用来标记是否能被继承，因此没有任何注解元素，是一个标记注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>该注解用来标记一个方法在重写父类（或接口）中的方法，也是一个标记注解。当编译器遇到这个注解时，会主动检查重写的条件，防止出现一些低级错误，如参数列表不符合、抛出了更宽泛的异常等。因此这个注解的存活周期只到编译时 (RetentionPolicy.SOURCE)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>这个注解用来标记某个类、方法、成员变量等是否被弃用。编译器会主动发出警告，如果一个弃用的 Java 元素被使用或者被重写在非 Deprecated 的方法中 (Compilers warn when a deprecated program element is used or overridden in non-deprecated code.)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h1><h2 id="普通注解"><a href="#普通注解" class="headerlink" title="普通注解"></a>普通注解</h2><p>在使用普通注解时需要指定注解中定义的所有注解元素的取值 (含有默认值的注解元素可以不指定，会使用默认值)。同时不能指定注解中没有定义的注解元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotation.java 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</span><br><span class="line">    <span class="function">String <span class="title">location</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java 使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以全部指定注解元素的值</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name=&quot;xuewenG&quot;, age = 21, location = &quot;China&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有默认值的注解元素可以使用默认值</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name=&quot;xuewenG&quot;, location = &quot;China&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。注解元素 location 没有默认值，必须被赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name=&quot;xuewenG&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。没有被定义的注解元素 level 不能出现在列表中</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name=&quot;xuewenG&quot;, location = &quot;China&quot;, level=&quot;LEVEL_A&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标记注解"><a href="#标记注解" class="headerlink" title="标记注解"></a>标记注解</h2><p>标记注解可以被直接使用，不需要给注解元素赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotation.java 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java 使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果一个注解中的<strong>所有注解元素都具有默认值</strong>，那么该注解也可以被当作标记注解使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotation.java 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;xuewenG&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</span><br><span class="line">    <span class="function">String <span class="title">location</span><span class="params">()</span> <span class="keyword">default</span> &quot;China&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java 使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元素注解"><a href="#单元素注解" class="headerlink" title="单元素注解"></a>单元素注解</h2><p>单元素注解只有一个特殊的地方，即在使用时可以不指定注解元素的名称（但是在定义注解时要按照约定来定义注解元素）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotation.java 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java 使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以指名注解元素名称</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;Value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以不指名注解元素名称</span></span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;Value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下使用方式是错误的，因为在定义单元素注解时没有按照约定将注解元素名称定义为 <code>value</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotation.java 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java 使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 错误。没有名称为 value 的注解元素</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;Value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。没有名称为 value 的注解元素</span></span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;Value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果一个注解中除了 value 注解元素之外还有其他注解，并且其他注解都含有默认值，那么这个注解也可以被当做单元素注解使用，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotation.java 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;xuewenG&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java 使用注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当作单元素注解使用</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;Value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当作单元素注解使用</span></span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;Value&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要覆盖默认值，则必须指明所有提到的注解元素的名称</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;Value&quot;, name = &quot;xuewnG&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User userC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6">The Java Language Specification, Java SE 8 Edition - Chapter 9.6. Annotation Types</a><br>JDK 1.8.0_231 Source Code</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相加</title>
    <url>/posts/leetcode/add-two-numbers/</url>
    <content><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>这道题主要考的就是合并两个链表，但是在合并的时候还要注意进位的问题，合并完成后也要考虑是否还有进位。</p>
<p>我第一次提交时，为了方便把合并链表的过程简写了，但是耗时好像有点高，只超过了 27 % 的提交（其实也就用了 3 ms）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode root = result;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> v2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> temp = v1 + v2 + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">            l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line">            l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后我把合并的过程拆分开了，主要是减少了判断两个链表是否为空的次数，耗时减少到了 2 ms：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode root = result;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = l1.val + l2.val + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = l1.val + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = l2.val + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">            result = result.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/posts/leetcode/cong-wei-dao-tou-da-yin-lian-biao-lco/</url>
    <content><![CDATA[<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1, 3, 2]</span><br><span class="line">输出：[2, 3, 1]</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= 链表长度 &lt;= 10000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>利用栈先进后出的特性可以实现反向打印链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(currentNode.val);</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            result[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是栈的操作很耗时，在 LeetCode 的提交中消耗了 2 ms 来执行。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>先遍历数组的长度，然后开辟一个数组来存放倒序的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> index = length - <span class="number">1</span>;</span><br><span class="line">        currentNode = head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result[index] = currentNode.val;</span><br><span class="line">            index--;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/posts/leetcode/er-cha-shu-de-jing-xiang-lcof/</url>
    <content><![CDATA[<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<span id="more"></span>

<p>例如输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>镜像输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4, 2, 7, 1, 3, 6, 9]</span><br><span class="line">输出：[4, 7, 2, 9, 6, 3, 1]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>利用二叉树的递归特性，直接递归地来交换每个节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        swap(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>利用深度优先遍历来访问二叉树中的节点，在访问这些节点时，交换他们的左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            TreeNode rootNode = stack.pop();</span><br><span class="line">            TreeNode leftNode = rootNode.left;</span><br><span class="line">            TreeNode rightNode = rootNode.right;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) stack.push(leftNode);</span><br><span class="line">            <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) stack.push(rightNode);</span><br><span class="line">            rootNode.left = rightNode;</span><br><span class="line">            rootNode.right = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>也可以使用广度优先遍历来遍历二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode rootNode = queue.poll();</span><br><span class="line">            TreeNode leftNode = rootNode.left;</span><br><span class="line">            TreeNode rightNode = rootNode.right;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) queue.offer(leftNode);</span><br><span class="line">            <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) queue.offer(rightNode);</span><br><span class="line">            rootNode.left = rightNode;</span><br><span class="line">            rootNode.right = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的深度</title>
    <url>/posts/leetcode/er-cha-shu-de-shen-du-lcof/</url>
    <content><![CDATA[<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<span id="more"></span>

<p>例如：</p>
<p>给定二叉树 [3, 9, 20, null, null, 15, 7]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>节点总数 &lt;= 10000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>利用二叉树的递归特性，一个二叉树的深度就等于其左右子树的深度中较深的那个深度加 1，即有：depth(tree) = max(depth(left), depth(right)) + 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>利用深度优先遍历来访问二叉树中的节点，在访问这些节点时，利用另一个栈来记录每个节点所处的深度，并和最大深度进行比较，下面是非递归实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; levelStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelStack.push(<span class="number">1</span>);</span><br><span class="line">            stack.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            TreeNode rootNode = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> currentLevel = levelStack.pop();</span><br><span class="line">            maxLevel = Math.max(maxLevel, currentLevel);</span><br><span class="line">            TreeNode leftNode = rootNode.left;</span><br><span class="line">            TreeNode rightNode = rootNode.right;</span><br><span class="line">            <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                levelStack.push(currentLevel + <span class="number">1</span>);</span><br><span class="line">                stack.push(leftNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                levelStack.push(currentLevel + <span class="number">1</span>);</span><br><span class="line">                stack.push(rightNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做需要记录每个节点的深度，这个过程很耗时，下面使用广度优先遍历来解决这个问题。</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>也可以使用广度优先遍历来遍历二叉树，也就是层次遍历，这样即可得到总共的层数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                TreeNode rootNode = queue.poll();</span><br><span class="line">                TreeNode leftNode = rootNode.left;</span><br><span class="line">                TreeNode rightNode = rootNode.right;</span><br><span class="line">                <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) queue.offer(leftNode);</span><br><span class="line">                <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) queue.offer(rightNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/posts/leetcode/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</url>
    <content><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现有矩阵 matrix 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= n &lt;= 1000</p>
<p>0 &lt;= m &lt;= 1000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>暴力法，直接遍历整个二维矩阵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] inner : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : inner) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>二维矩阵中每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序的特点，说明<strong>对于任意一个数字，它左边的数字都比他小，下面的数字都比他大</strong>。</p>
<p>我们可以从右上角开始查找，设当前值为 value = matrix[i][j]：</p>
<ol>
<li>如果 value &lt; target，那么我们就需要更大的值，即使 i++，以切换到下一行</li>
<li>如果 value &gt; target，那么我们就需要更小的值，即使 j–，以切换到左边一个数字</li>
<li>如果 value == target，那么即可返回 true</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] inner = matrix[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = inner.length - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span> (value == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/posts/leetcode/fei-bo-na-qi-shu-lie-lcof/</url>
    <content><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9 + 7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= n &lt;= 100</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接递归求解，在递归的过程中记录中间结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(data, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> cache = data[n];</span><br><span class="line">        <span class="keyword">if</span> (cache == -<span class="number">1</span>) &#123;</span><br><span class="line">            cache = (fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">            data[n] = cache;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/posts/leetcode/ji-qi-ren-de-yun-dong-fan-wei-lcof/</url>
    <content><![CDATA[<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个 m 行 n 列的方格，从坐标 [0, 0] 到坐标 [m-1, n-1]。</p>
<p>一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。</p>
<p>例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为3 + 5 + 3 + 7 = 18。但它不能进入方格 [35, 38]，因为3 + 5 + 3 + 8 = 19。</p>
<p>请问该机器人能够到达多少个格子？</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul>
<li>1 &lt;= n, m &lt;= 100</li>
<li>0 &lt;= k &lt;= 20</li>
</ul>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>使用广度优先遍历来访问二维矩阵，在访问的过程中判断路径和记录已经访问的点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += y % <span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;(m * n);</span><br><span class="line">        queue.add(node);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">int</span> x = node.x;</span><br><span class="line">            <span class="keyword">int</span> y = node.y;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] direction = directions[i];</span><br><span class="line">                <span class="keyword">int</span> x2 = x + direction[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y2 = y + direction[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x2 &lt; <span class="number">0</span> || y2 &lt; <span class="number">0</span> || x2 &gt;= m || y2 &gt;= n || visited[x2][y2] || add(x2, y2) &gt; k) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(x2, y2));</span><br><span class="line">                visited[x2][y2] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/posts/leetcode/ju-zhen-zhong-de-lu-jing-lcof/</url>
    <content><![CDATA[<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的 3 × 4 的矩阵中包含一条字符串 “bfce” 的路径（路径中的字母用加粗标出）。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;E&quot;], [&quot;S&quot;, &quot;F&quot;, &quot;C&quot;, &quot;S&quot;], [&quot;A&quot;, &quot;D&quot;, &quot;E&quot;, &quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>可以对矩阵中的每个元素采用回溯的方法进行尝试，若以该节点有一条路径满足条件则返回。</p>
<p>在回溯的过程中要记录已经访问的节点，回溯之后还要注意将访问标志恢复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] word;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.word = word.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line">        <span class="keyword">this</span>.m = board.length;</span><br><span class="line">        <span class="keyword">this</span>.n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] inner = board[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inner.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word[index]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + direction[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = j + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; m - <span class="number">1</span> || y &lt; <span class="number">0</span> || y &gt; n - <span class="number">1</span> || visited[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(x, y, index + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中倒数第 k 个节点</title>
    <url>/posts/leetcode/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</url>
    <content><![CDATA[<h1 id="链表中倒数第-k-个节点"><a href="#链表中倒数第-k-个节点" class="headerlink" title="链表中倒数第 k 个节点"></a>链表中倒数第 k 个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, 和 k = 2</span><br><span class="line">返回链表：4 -&gt; 5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>先遍历一遍取得链表的长度 length，再遍历一次直到 length - k 的位置，返回此处的节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - k; i++) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>使用双指针的方法，先将一个指针先移动 k 个节点，然后再将两个指针用同样的速度向前移动，当一个指针到达链表末尾时，另一个指针的位置就是倒数第 k 个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/posts/leetcode/longest-palindromic-substring/</url>
    <content><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">注意：&quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>将字符串中的每个字符取出，依次以这些字符为中心取回文子串，记录这些子串中最长的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLength = search(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> currentLength2 = search(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> currentMax = Math.max(currentLength, currentLength2);</span><br><span class="line">            <span class="keyword">if</span> (currentMax &gt; maxLength) &#123;</span><br><span class="line">                centerIndex = i;</span><br><span class="line">                maxLength = currentMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = centerIndex - (maxLength - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = centerIndex + (maxLength) / <span class="number">2</span> + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 解法二</span><br><span class="line"></span><br><span class="line">解法二利用了动态规划，转移方程如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中 dp[i][j] 代表子串 s[i:j] 是否是一个回文串。</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    boolean[][] visited;</span><br><span class="line">    boolean[][] dp;</span><br><span class="line"></span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line">        if (s == null || s.equals(&quot;&quot;)) return s;</span><br><span class="line">        int maxLength = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        int length = s.length();</span><br><span class="line">        visited = new boolean[length][length];</span><br><span class="line">        dp = new boolean[length][length];</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            for (int j = i; j &lt; length; j++) &#123;</span><br><span class="line">                boolean cur = dpf(s, i, j);</span><br><span class="line">                if (cur) &#123;</span><br><span class="line">                    int curLength = j - i + 1;</span><br><span class="line">                    if (curLength &gt; maxLength) &#123;</span><br><span class="line">                        maxLength = curLength;</span><br><span class="line">                        left = i;</span><br><span class="line">                        right = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(left, right + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean dpf(String s, int left, int right) &#123;</span><br><span class="line">        if (visited[left][right]) &#123;</span><br><span class="line">            return dp[left][right];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            visited[left][right] = true;</span><br><span class="line">            if (left == right) &#123;</span><br><span class="line">                return dp[left][right] = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                boolean b = s.charAt(left) == s.charAt(right);</span><br><span class="line">                if (left - right == 1) &#123;</span><br><span class="line">                    return dp[left][right] = b;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return dp[left][right] = b &amp;&amp; dpf(s, left + 1, right - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

TODO  优化动态规划
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/posts/leetcode/longest-substring-without-repeating-characters/</url>
    <content><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;abcabcbb&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;bbbbb&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;pwwkew&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>这题我一开始用到的是比较暴力的方法，直接取出所有的子串，再判断每个子串中是否含有重复字符，并记录最长的不含重复字符的子串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                String sub = s.substring(i, j);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.check(sub)) &#123;</span><br><span class="line">                    max = Math.max(max, sub.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">            Character ret = map.put(ch, ch);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出意料，这种解法直接超时了。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>解法二是我对解法一的一点点优化。在第二层循环中移动右指针时，如果遇到了重复的字符就直接结束该层循环，将左指针右移一位，开始下一次循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                Character c = s.charAt(j);</span><br><span class="line">                Character ch = map.put(c, c);</span><br><span class="line">                <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    max = Math.max(max, j - i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化一些后的解法以 110 ms 的成绩通过了测试，但是和优秀题解还是有不小的差距。</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>我看了一下官方的题解，官方采用了一种叫滑动窗口的方法。我发现在题解二中的优化还不够充分，没有利用到上一次外层循环中的判重结果，参考官方题解后重新写出以下解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Character ch;</span><br><span class="line">        <span class="keyword">for</span> (left = <span class="number">0</span>; left &lt; s.length(); left++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">                ch = s.charAt(right);</span><br><span class="line">                <span class="keyword">if</span> (set.contains(ch)) <span class="keyword">break</span>;</span><br><span class="line">                set.add(ch);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(right - left, ans);</span><br><span class="line">            set.remove(s.charAt(left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种解法的时间直接降到了 8 ms。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>HashMap</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶问题</title>
    <url>/posts/leetcode/qing-wa-tiao-tai-jie-wen-ti-lcof/</url>
    <content><![CDATA[<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9 + 7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= n &lt;= 100</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>实质上就是一个斐波那契数列问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.fill(data, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cache = data[n];</span><br><span class="line">        <span class="keyword">if</span> (cache == -<span class="number">1</span>) &#123;</span><br><span class="line">            cache = (numWays(n - <span class="number">1</span>) + numWays(n - <span class="number">2</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">            data[n] = cache;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素 II</title>
    <url>/posts/leetcode/remove-duplicates-from-sorted-list-ii/</url>
    <content><![CDATA[<h1 id="删除排序链表中的重复元素-II"><a href="#删除排序链表中的重复元素-II" class="headerlink" title="删除排序链表中的重复元素 II"></a>删除排序链表中的重复元素 II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5</span><br><span class="line">输出：1 -&gt; 2 -&gt; 5</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1 -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3</span><br><span class="line">输出：2 -&gt; 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接定义三个指针来扫描这个链表。扫描过程要保存删除过的节点，遍历完成后要检查最后一个元素是否需要删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        root.next = head;</span><br><span class="line">        Integer deleteValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode lastNode = root;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        ListNode nextNode = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nextNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteValue != <span class="keyword">null</span> &amp;&amp; deleteValue == currentNode.val) &#123;</span><br><span class="line">                lastNode.next = nextNode;</span><br><span class="line">                currentNode = nextNode;</span><br><span class="line">                <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                nextNode = currentNode.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (currentNode.val == nextNode.val) &#123;</span><br><span class="line">                deleteValue = currentNode.val;</span><br><span class="line">                lastNode.next = nextNode.next;</span><br><span class="line">                currentNode = lastNode.next;</span><br><span class="line">                <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                nextNode = currentNode.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextNode = nextNode.next;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">                lastNode = lastNode.next;</span><br><span class="line">                deleteValue = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="keyword">null</span> &amp;&amp; deleteValue != <span class="keyword">null</span> &amp;&amp; deleteValue == currentNode.val) &#123;</span><br><span class="line">                lastNode.next = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>这是评论区中的一个人提出的解法，我觉得这个方法很妙，思路很清晰。</p>
<p>这个解法使用了双指针来记录重复元素的区间。</p>
<ol>
<li>右指针不停向右移动，直到 left.value != right.value</li>
<li>然后根据 left 和 right 的距离来删除元素</li>
<li>接着将 left 指针移动到 right 的位置继续扫描</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;  <span class="comment">// 若head为空则直接返回null</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);  <span class="comment">// 建立一个虚拟头结点</span></span><br><span class="line">        ListNode tail = dummy;  <span class="comment">// 定义一个尾巴，用于尾插法。</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode l = head, r = head; l != <span class="keyword">null</span>; l = r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r != <span class="keyword">null</span> &amp;&amp; r.val == l.val) r = r.next;  <span class="comment">// 只要r不为空并且与l的值相等则一直向后移动</span></span><br><span class="line">            <span class="keyword">if</span> (l.next == r) &#123;  <span class="comment">// 若长度为1，则通过尾插法加入。</span></span><br><span class="line">                tail.next = l;  <span class="comment">// 基本的尾插法                                         </span></span><br><span class="line">                tail = l;                                               </span><br><span class="line">                tail.next = <span class="keyword">null</span>;  <span class="comment">// 这里记得将尾部的后面置为null，不然可能后面会带着一些其他的节点。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：optimjie</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/javashuang-zhi-zhen-dai-ma-jiao-duan-rong-yi-li-ji/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/posts/leetcode/reverse-linked-list/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转一个单链表。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">输出：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL</span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list">https://leetcode-cn.com/problems/reverse-linked-list</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接反转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

TODO  递归地反转链表
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/posts/leetcode/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</url>
    <content><![CDATA[<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n - 1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>2 &lt;= n &lt;= 100000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>首先想到的是利用 HashSet，遍历数组，每遍历一个元素就添加到 HashSet 中，在判断返回值是否为 false，若是则说明这个数字已经出现过一次了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> current : nums) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> newItem = set.add(current);</span><br><span class="line">            <span class="keyword">if</span> (!newItem) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种解法的时间复杂度和空间复杂度都是 O(n)，下面尝试使用更低的空间复杂度来解决这个问题。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>还可以将数组进行排序。根据题意，排序后的数组中对于每个下标 i 都有 nums[i] != nums[i + 1]，否则就说明这个位置上的元素是重复的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>也可以不进行排序，对数组进行一遍扫描：</p>
<ol>
<li>设当前元素为 current = abs(nums[i])</li>
<li>取出 nums[current] 的值，检查其是否为负数<ol>
<li>如果是，说明 current 已经出现过</li>
<li>否则令 nums[current] = 0 - nums[current] 供下次检查</li>
</ol>
</li>
</ol>
<p>要注意的是，需要对数字 0 进行单独计数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = nums[current];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[current] = -target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/posts/leetcode/three-sum/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>注意：答案中不可以包含重复的三元组。</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>先对数组进行排序，然后在每层循环开始前都判断当前数字是否和上一次循环的数字相等，相等就跳过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k != j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">                        tmp.add(nums[i]);</span><br><span class="line">                        tmp.add(nums[j]);</span><br><span class="line">                        tmp.add(nums[k]);</span><br><span class="line">                        result.add(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样直接暴力循环会超时。</p>
<p>因为排序后的数组是正序的，因此可以在第三层循环从后向前遍历，当三个数值和小于 0 时，继续循环下去一定会继续小于 0，所以当和小于 0 时，可以直接跳出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = nums.length - <span class="number">1</span>; k &gt; j; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">                        tmp.add(nums[i]);</span><br><span class="line">                        tmp.add(nums[j]);</span><br><span class="line">                        tmp.add(nums[k]);</span><br><span class="line">                        result.add(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样依然会超时，下面继续改进。</p>
<p>考虑到数组是升序的，当 nums[i] + nums[j] + nums[k] == 0 时，即可进入第二层循环的下一步，此时 j++，那么 nums[j] 变得更大，因此 nums[k] 需要更小，才能使得三数值和等于 0，所以可以从上一次 k 的位置继续向左移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &gt; j; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">                        tmp.add(nums[i]);</span><br><span class="line">                        tmp.add(nums[j]);</span><br><span class="line">                        tmp.add(nums[k]);</span><br><span class="line">                        result.add(tmp);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/posts/leetcode/ti-huan-kong-ge-lcof/</url>
    <content><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成 “%20”。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= s 的长度 &lt;= 10000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接扫描字符串，使用 StringBuilder 来拼接新的字符串。在扫描的过程中遇到空格就添加 “%20”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/posts/leetcode/two-sum/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><p>我在做这道题的时候没想那么多，就直接来了两层循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果当然是对的，但是耗时有点长，下面看了看官方给的解答。</p>
<h2 id="优秀题解"><a href="#优秀题解" class="headerlink" title="优秀题解"></a>优秀题解</h2><h3 id="两遍-Hash-表"><a href="#两遍-Hash-表" class="headerlink" title="两遍 Hash 表"></a>两遍 Hash 表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题解还是比较容易看懂的，就是使用了 HashMap 来代替了查找第二个数字的内层循环，把时间复杂度从 O(n ^ 2) 降到了 O(n)。</p>
<p>但是这种解法和我的解法在有些测试样例下会输出不同的结果（都是正确的），比如对于以下样例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">target = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>我的解法得到的答案是：[0, 1]</p>
<p>而这种方法得到的应该是：[0, 2]</p>
<p>原因应该是在向 HashMap 中放入 key 重复的元素时，会覆盖之前的元素，所以会使用最后出现的数字；而我的解法中是从前向后遍历的，所以会直接使用第一次遇到的数字。</p>
<h3 id="一遍-Hash-表"><a href="#一遍-Hash-表" class="headerlink" title="一遍 Hash 表"></a>一遍 Hash 表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题解的思路更巧妙，最多只遍历了一次数组，因此时间复杂度也是 O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/posts/leetcode/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</url>
    <content><![CDATA[<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<p>例如，数组 [3, 4, 5, 1, 2] 为 [1, 2, 3, 4, 5] 的一个旋转，该数组的最小值为 1。  </p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接遍历整个数组，记录最小的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; min) &#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这么做就没有利用到数组部分有序的特点，时间复杂度达到了 O(n)，下面利用二分查找的思想来求解。</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h2><p>根据题目对旋转数组的描述可知，这个数组可以分为两个有序数组，并且后面一个数组中的每个元素都小于前面数组中的第一个元素。</p>
<p>利用二分查找的思路，定义两个指针 left、right 分别指向数组的最开始和结尾：</p>
<ol>
<li>取两个指针的中间数字 numbers[mid]，其中 mid = (left + right) / 2</li>
<li>如果 numbers[mid] &gt; right，就说明 mid 在最小数字的左边，需要将 left = mid + 1</li>
<li>如果 numbers[mid] &lt; right，就说明 mid 在最小数字的右边，需要将 right = mid</li>
</ol>
<p>重复上述步骤即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/posts/leetcode/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</url>
    <content><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1)</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;, &quot;appendTail&quot;, &quot;deleteHead&quot;, &quot;deleteHead&quot;]</span><br><span class="line">[[], [3], [], []]</span><br><span class="line">输出：[null, null, 3, -1]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;, &quot;deleteHead&quot;, &quot;appendTail&quot;, &quot;appendTail&quot;, &quot;deleteHead&quot;, &quot;deleteHead&quot;]</span><br><span class="line">[[], [], [5], [2], [], []]</span><br><span class="line">输出：[null, -1, null, null, 5, 2]</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>1 &lt;= values &lt;= 10000</p>
<p>最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接使用两个栈 A、B，栈 A 用来存放 push 进的元素，需要 pop 时再将栈 A 中的元素先 pop 到栈 B 中，再在栈 B 进行 pop，这样就可以实现队列的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.size() + stack2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/posts/leetcode/zhong-jian-er-cha-shu-lcof/</url>
    <content><![CDATA[<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>例如，给出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>0 &lt;= 节点个数 &lt;= 5000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>根据二叉树的先序遍历和中序遍历可知：</p>
<ol>
<li>先序遍历得到的序列的第一个元素是这棵树的根节点</li>
<li>中序遍历得到的序列中<strong>根节点</strong>两边的元素分别是左子树和右子树中序遍历序列</li>
<li>一棵树的先序遍历和中序遍历得到的序列中元素数量一致</li>
</ol>
<p>根据上面三条，即可得到这棵树的根节点、左右子树的先序遍历序列和中序遍历序列，然后即可递归地求解左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(preorder.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, inorder,</span><br><span class="line">                <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span>[] inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> preorderStart,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> preorderEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> inorderStart,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> inorderEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = preorder[preorderStart];</span><br><span class="line">        TreeNode rootNode = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        <span class="keyword">if</span> (preorderStart == preorderEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> rootNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootIndex = map.get(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength = rootIndex - inorderStart;</span><br><span class="line">        <span class="keyword">int</span> rightLength = inorderEnd - rootIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPreorderStart = preorderStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPreorderEnd = leftPreorderStart + leftLength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightPreorderStart = leftPreorderEnd + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightPreorderEnd = rightPreorderStart + rightLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftInorderStart = inorderStart;</span><br><span class="line">        <span class="keyword">int</span> leftInorderEnd = leftInorderStart + leftLength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightInorderStart = leftInorderEnd + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> rightInorderEnd = rightInorderStart + rightLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftLength != <span class="number">0</span>)</span><br><span class="line">            rootNode.left = buildTree(preorder, inorder,</span><br><span class="line">                    leftPreorderStart, leftPreorderEnd,</span><br><span class="line">                    leftInorderStart, leftInorderEnd);</span><br><span class="line">        <span class="keyword">if</span> (rightLength != <span class="number">0</span>)</span><br><span class="line">            rootNode.right = buildTree(preorder, inorder,</span><br><span class="line">                    rightPreorderStart, rightPreorderEnd,</span><br><span class="line">                    rightInorderStart, rightInorderEnd);</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/posts/leetcode/zuo-xuan-zhuan-zi-fu-chuan-lcof/</url>
    <content><![CDATA[<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串 “abcdefg” 和数字 2，该函数将返回左旋转两位得到的结果 “cdefgab”。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出：&quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>1 &lt;= k &lt; s.length &lt;= 10000</p>
<blockquote>
<p>题目来源：力扣（LeetCode）<br>题目链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a><br>题目著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>直接使用 String.substring 方法来截取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>使用 StringBuilder 来一位一位的拼接字符串。在拼接的过程中可以直接从 n 的位置开始取字符，然后一直循环到 (s.length + n) % s.length 的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; length + n; i++) &#123;</span><br><span class="line">            stringBuilder.append(s.charAt(i % length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 中配置跨域</title>
    <url>/posts/linux/nginx-cors/</url>
    <content><![CDATA[<h1 id="Nginx-中配置跨域"><a href="#Nginx-中配置跨域" class="headerlink" title="Nginx 中配置跨域"></a>Nginx 中配置跨域</h1><h2 id="允许单域名跨域"><a href="#允许单域名跨域" class="headerlink" title="允许单域名跨域"></a>允许单域名跨域</h2><p>如果只需要允许一个域名跨域，直接在 server 段中添加以下配置：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin &#x27;http://example.com&#x27;;</span><br><span class="line">    add_header Access-Control-Allow-Credentials &#x27;true&#x27;;</span><br><span class="line">    add_header Access-Control-Allow-Methods &#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;;</span><br><span class="line">    add_header Access-Control-Allow-Headers &#x27;Content-Type, Authorization&#x27;;</span><br><span class="line">    if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">        return 204;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="允许单域名跨域-1"><a href="#允许单域名跨域-1" class="headerlink" title="允许单域名跨域"></a>允许单域名跨域</h2><p>如果需要允许多域名跨域，可以先在 http 段中添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map $http_origin $cors_origin &#123;</span><br><span class="line">    default 0;</span><br><span class="line">    &quot;~http://example.com&quot; http://example.com;</span><br><span class="line">    &quot;~http://www.example.com&quot; http://www.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 server 段中添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin $cors_origin;</span><br><span class="line">    add_header Access-Control-Allow-Credentials &#x27;true&#x27;;</span><br><span class="line">    add_header Access-Control-Allow-Methods &#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;;</span><br><span class="line">    add_header Access-Control-Allow-Headers &#x27;Content-Type, Authorization&#x27;;</span><br><span class="line">    if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">        return 204;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后重启 nginx 服务生效。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用代理连接远程主机</title>
    <url>/posts/linux/ssh-with-proxy/</url>
    <content><![CDATA[<h1 id="使用代理连接远程主机"><a href="#使用代理连接远程主机" class="headerlink" title="使用代理连接远程主机"></a>使用代理连接远程主机</h1><p>现在有两台主机 Proxy 和 Target，如果客户端直接连接 Target 时的网络不畅通，而客户端和 Proxy、Proxy 和 Target 之间的网络情况比较好，那么就客户端就可以通过 Proxy 来连接 Target。</p>
<span id="more"></span>

<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>使用 Socks5 代理来访问（本文不介绍如何搭建 Socks5 代理）。在连接 Target 时，客户端会通过 Socks5 代理向 Target 发送数据。</p>
<p>假设客户端在本地端口 <code>10808</code> 上有一个 Socks5 代理服务。打开或创建 <code>~/.ssh/config</code> 文件，写入以下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是用来保存 SSH 客户端的配置的文件，在每次连接时，客户端都会从这个文件中读取配置。</span><br><span class="line"></span><br><span class="line">Host $&#123;Target_Hostname&#125;</span><br><span class="line">    HostName $&#123;Target_Hostname&#125;</span><br><span class="line">    ProxyCommand connect -a none -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure>

<p>将 ${Target_Hostname} 替换为自己的 Target 的地址。</p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>使用 SSH 自带的代理功能。在连接 Target 之前，客户端会先与 Proxy 建立 SSH 连接，然后再使用这条连接，向 Target 发送数据。</p>
<p>打开上述的配置文件，写入以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host $&#123;Target_Hostname&#125;</span><br><span class="line">    HostName $&#123;Target_Hostname&#125;</span><br><span class="line">    ProxyCommand ssh -W %h:%p $&#123;Proxy_Hostname&#125;</span><br></pre></td></tr></table></figure>

<p>将 ${Target_Hostname} 和 ${Proxy_Hostname} 替换为自己的 Target 和 Proxy 的地址。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
        <tag>Proxy</tag>
        <tag>Socks5</tag>
      </tags>
  </entry>
  <entry>
    <title>实验二 汇编语言程序设计</title>
    <url>/posts/masm/experiment-02/</url>
    <content><![CDATA[<h1 id="实验二-汇编语言程序设计"><a href="#实验二-汇编语言程序设计" class="headerlink" title="实验二  汇编语言程序设计"></a>实验二  汇编语言程序设计</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>掌握顺序和循环程序结构和设计方法。</li>
<li>熟悉在 PC 机上建立、汇编、连接、调试和运行 8086/8088 汇编语言程序的过程。</li>
</ol>
<span id="more"></span>

<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>X、Y、Z、V 均为字变量，在 X、Y、Z、V 字单元中存放是 16 位带符号数。试编写汇编语言程序完成以下功能：</li>
</ol>
<ul>
<li>计算表达式值 (V – (X * Y + Z - 720)) / X</li>
<li>将上述表达式运算结果整数放在 SUM1 单元，余数放在 SUM2 单元</li>
</ul>
<ol start="2">
<li>使用地址表实现如下功能：根据输入的数字 1 ~ 7，分别显示相应的英文星期名，如果输入其他字符，则重新输入。</li>
<li>求一个班 50 名学生成绩的平均值、最大值和最小值，并将结果显示出来。</li>
<li>从键盘读入一个字符串，以 Enter 结束，字符串不超过 60 个字符，并打印该字符串；查找中间是否有自己名字拼音首字母缩写的子串。如果有，输出 “TRUE”；否则，输出 “FALSE”。</li>
</ol>
<h2 id="实验过程和程序"><a href="#实验过程和程序" class="headerlink" title="实验过程和程序"></a>实验过程和程序</h2><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务 1"></a>任务 1</h3><p>X、Y、Z、V 均为字变量，在 X、Y、Z、V 字单元中存放是 16 位带符号数。试编写汇编语言程序完成以下功能：</p>
<ul>
<li>计算表达式值 (V – (X * Y + Z - 720)) / X</li>
<li>将上述表达式运算结果整数放在 SUM1 单元，余数放在 SUM2 单元</li>
</ul>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; cal.asm</span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        X       dw  021cH</span><br><span class="line">        Y       dw  0001H</span><br><span class="line">        Z       dw  0FFFFH</span><br><span class="line">        V       dw  0438H</span><br><span class="line">        SUM1    dw  0H</span><br><span class="line">        SUM2    dw  0H</span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data, ss:stack</span><br><span class="line">start:</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line">        </span><br><span class="line">        mov     ax, X</span><br><span class="line">        mul     Y</span><br><span class="line">        mov     cx, ax</span><br><span class="line">        mov     bx, dx</span><br><span class="line">        mov     ax, Z</span><br><span class="line">        cwd</span><br><span class="line">        add     cx, ax</span><br><span class="line">        adc     bx, dx</span><br><span class="line">        mov     dx, 0</span><br><span class="line">        mov     ax, 021CH</span><br><span class="line">        sub     cx, ax</span><br><span class="line">        sbb     bx, dx</span><br><span class="line">        mov     ax, V</span><br><span class="line">        cwd</span><br><span class="line">        sub     ax, cx</span><br><span class="line">        sbb     dx, bx</span><br><span class="line">        idiv    X</span><br><span class="line">        mov     SUM1, ax</span><br><span class="line">        mov     SUM2, dx</span><br><span class="line"></span><br><span class="line">        mov     ax, 4c00h</span><br><span class="line">        int     21h</span><br><span class="line">code    ends</span><br><span class="line">        end start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h3 id="任务-2"><a href="#任务-2" class="headerlink" title="任务 2"></a>任务 2</h3><p>使用地址表实现如下功能：根据输入的数字 1 ~ 7，分别显示相应的英文星期名，如果输入其他字符，则重新输入。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; table.asm</span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        msg         db &#x27;enter the number$&#x27;</span><br><span class="line">        monday      db &#x27;monday$&#x27;</span><br><span class="line">        tuesday     db &#x27;tuesday$&#x27;</span><br><span class="line">        wednesday   db &#x27;wednesday$&#x27;</span><br><span class="line">        thursday    db &#x27;thursday$&#x27;</span><br><span class="line">        friday      db &#x27;friday$&#x27;</span><br><span class="line">        saturday    db &#x27;saturday$&#x27;</span><br><span class="line">        sunday      db &#x27;sunday$&#x27;</span><br><span class="line">        addr        dw  L1, L2, L3, L4, L5, L6, L7</span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data, ss:stack</span><br><span class="line">start:</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line"></span><br><span class="line">        lea     dx, msg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        mov     ah, 01H</span><br><span class="line">        int     21H</span><br><span class="line">        </span><br><span class="line">        mov     bl, al</span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     al, bl</span><br><span class="line"></span><br><span class="line">        cmp     al, &#x27;1&#x27;</span><br><span class="line">        jb      start</span><br><span class="line">        cmp     al, &#x27;8&#x27;</span><br><span class="line">        ja      start</span><br><span class="line">        and     ax, 000fH</span><br><span class="line">        dec     ax</span><br><span class="line">        shl     ax, 1</span><br><span class="line">        mov     bx, ax</span><br><span class="line">        jmp     addr[bx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    L1: </span><br><span class="line">        lea dx, monday</span><br><span class="line">        jmp print</span><br><span class="line">    L2:</span><br><span class="line">        lea dx, tuesday</span><br><span class="line">        jmp print</span><br><span class="line">    L3:</span><br><span class="line">        lea dx, wednesday</span><br><span class="line">        jmp print</span><br><span class="line">    L4:</span><br><span class="line">        lea dx, thursday</span><br><span class="line">        jmp print</span><br><span class="line">    L5:</span><br><span class="line">        lea dx, friday</span><br><span class="line">        jmp print</span><br><span class="line">    L6:</span><br><span class="line">        lea dx, saturday</span><br><span class="line">        jmp print</span><br><span class="line">    L7:</span><br><span class="line">        lea dx, sunday</span><br><span class="line">        jmp print</span><br><span class="line"></span><br><span class="line">    print:</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        mov     ax, 4c00H</span><br><span class="line">        int     21H</span><br><span class="line">code    ends</span><br><span class="line">        end start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h3 id="任务-3"><a href="#任务-3" class="headerlink" title="任务 3"></a>任务 3</h3><p>求一个班 50 名学生成绩的平均值、最大值和最小值，并将结果显示出来。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; grade.asm</span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        grade   db  52H, 50H, 52H, 5FH, 52H, 5EH, 50H, 52H, 50H, 54H</span><br><span class="line">        sum     dw  0H  ; 0349H</span><br><span class="line">        avg     db  0H  ; 54H</span><br><span class="line">        max     db  0H  ; 5FH</span><br><span class="line">        min     db  0H  ; 50H</span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data, ss:stack</span><br><span class="line">start:</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line"></span><br><span class="line">        ; calulate sum</span><br><span class="line">        mov     ax, 0H</span><br><span class="line">        mov     cx, 0aH</span><br><span class="line">        mov     si, 0H</span><br><span class="line">    begin:</span><br><span class="line">        add     al, grade[si]</span><br><span class="line">        adc     ah, 0H</span><br><span class="line">        inc     si</span><br><span class="line">        loop    begin</span><br><span class="line">        mov     sum, ax</span><br><span class="line"></span><br><span class="line">        ; calculate avg</span><br><span class="line">        mov     bl, 0aH</span><br><span class="line">        div     bl</span><br><span class="line">        mov     avg, al</span><br><span class="line"></span><br><span class="line">        ; min</span><br><span class="line">        mov si, 01H</span><br><span class="line">        mov al, grade[0H]</span><br><span class="line">        mov cx, 09H</span><br><span class="line">    beginMin:</span><br><span class="line">        cmp al, grade[si]</span><br><span class="line">        jbe loopMin</span><br><span class="line">        mov al, grade[si]</span><br><span class="line">    loopMin:</span><br><span class="line">        inc si</span><br><span class="line">        loop beginMin</span><br><span class="line">        mov min, al</span><br><span class="line"></span><br><span class="line">        ; max</span><br><span class="line">        mov si, 01H</span><br><span class="line">        mov al, grade[0H]</span><br><span class="line">        mov cx, 09H</span><br><span class="line">    beginMax:</span><br><span class="line">        inc si</span><br><span class="line">        cmp al, grade[si]</span><br><span class="line">        jae loopMax</span><br><span class="line">        mov al, grade[si]</span><br><span class="line">    loopMax:</span><br><span class="line">        loop beginMax</span><br><span class="line">        mov max, al</span><br><span class="line"></span><br><span class="line">        mov     ax, 4c00H</span><br><span class="line">        int     21H</span><br><span class="line">code    ends</span><br><span class="line">        end start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h3 id="任务-4"><a href="#任务-4" class="headerlink" title="任务 4"></a>任务 4</h3><p>从键盘读入一个字符串，以 Enter 结束，字符串不超过 60 个字符，并打印该字符串；查找中间是否有自己名字拼音首字母缩写的子串。如果有，输出 “TRUE”；否则，输出 “FALSE”。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; string.asm</span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        buf         db  50, ?, 50 dup(&#x27;$&#x27;)</span><br><span class="line">        msg         db  &#x27;enter a str: &#x27;, 0dH, 0aH, &#x27;$&#x27;</span><br><span class="line">        trueMsg     db  &#x27;True&#x27;, 0dH, 0aH, &#x27;$&#x27;</span><br><span class="line">        falseMsg    db  &#x27;False&#x27;, 0dH, 0aH, &#x27;$&#x27;</span><br><span class="line">        keyWord     db  &#x27;gxw$&#x27;</span><br><span class="line"></span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data, ss:stack</span><br><span class="line">start:</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line"></span><br><span class="line">        ; 提示消息</span><br><span class="line">        lea     dx, msg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; 读取字符串</span><br><span class="line">        lea     dx, buf</span><br><span class="line">        mov     ah, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; 换行</span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; 查找字符串</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     es, ax</span><br><span class="line">        cld</span><br><span class="line"></span><br><span class="line">        lea     bx, buf + 01H</span><br><span class="line">        lea     dx, buf + 02H</span><br><span class="line">        add     dl, buf[01H]</span><br><span class="line">        adc     dh, 0H</span><br><span class="line">    cmpBegin:</span><br><span class="line">        inc     bx</span><br><span class="line">        cmp     dx, bx</span><br><span class="line">        jb      done</span><br><span class="line">        mov     cx, 03H</span><br><span class="line">        mov     si, bx</span><br><span class="line">        lea     di, keyWord</span><br><span class="line">        repz    cmpsb</span><br><span class="line">        jnz     cmpBegin</span><br><span class="line"></span><br><span class="line">        lea     dx, trueMsg</span><br><span class="line">        jmp     endFlag</span><br><span class="line"></span><br><span class="line">    done:</span><br><span class="line">        lea     dx, falseMsg</span><br><span class="line"></span><br><span class="line">    endFlag:</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        mov     ax, 4c00H</span><br><span class="line">        int     21H</span><br><span class="line">code    ends</span><br><span class="line">        end start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="任务-1-1"><a href="#任务-1-1" class="headerlink" title="任务 1"></a>任务 1</h3><p>如下代码所示，在 X、Y、Z、V 变量中分别存了几个数字，运行程序，计算结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data    segment</span><br><span class="line">        X       dw  021cH</span><br><span class="line">        Y       dw  0001H</span><br><span class="line">        Z       dw  0FFFFH</span><br><span class="line">        V       dw  0438H</span><br><span class="line">        SUM1    dw  0H</span><br><span class="line">        SUM2    dw  0H</span><br><span class="line">data    ends</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-02/task-01/result.png" alt="运行结果"></p>
<p>程序得到了正确的结果：商是 2，余数是 1。</p>
<h3 id="任务-2-1"><a href="#任务-2-1" class="headerlink" title="任务 2"></a>任务 2</h3><p>运行结果如图所示，可以正常转换：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-02/task-02/result-01.png" alt="转换结果 1"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-02/task-02/result-02.png" alt="转换结果 2"></p>
<h3 id="任务-3-1"><a href="#任务-3-1" class="headerlink" title="任务 3"></a>任务 3</h3><p>为了方便数据录入，我在编写代码时只考虑了 10 个成绩，如下图，在 grade 数组中有 10 个成绩。下面的为结果存放的内存，注释部分为期待的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data    segment</span><br><span class="line">        grade   db  52H, 50H, 52H, 5FH, 52H, 5EH, 50H, 52H, 50H, 54H</span><br><span class="line">        sum     dw  0H  ; 0349H</span><br><span class="line">        avg     db  0H  ; 54H</span><br><span class="line">        max     db  0H  ; 5FH</span><br><span class="line">        min     db  0H  ; 50H</span><br><span class="line">data    ends</span><br></pre></td></tr></table></figure>

<p>运行程序：可以看到结果正确：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-02/task-03/result.png" alt="运行结果"></p>
<h3 id="任务-4-1"><a href="#任务-4-1" class="headerlink" title="任务 4"></a>任务 4</h3><p>在此题中，我的名字拼音首字母为 “gxw”，在编写代码后，运行程序：</p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-02/task-04/result-01.png" alt="比较结果 1"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-02/task-04/result-02.png" alt="比较结果 2"></p>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次实验和上一次实验最大的不同是本次实验将代码写在了文件中，然后用 MASM 和 LINK 工具来编译和链接。这样写代码时更加方便，代码也可以保留下来。</p>
<p>实验中用到了地址表，相当于 switch 语句。可以根据需要跳转到不同的语句，比如第二题中，根据用户输入来跳转到不同的输出语句。</p>
<p>实验中还用到了循环语句的写法，使用循环可以简化程序。例如对数组的求和以及遍历数组。</p>
<p>实验中用到了比较字符串的指令和重复前缀，结合这两个命令可以实现从字符串中查找子串的目的。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>实验一 Debug 程序的使用</title>
    <url>/posts/masm/experiment-01/</url>
    <content><![CDATA[<h1 id="实验一-Debug-程序的使用"><a href="#实验一-Debug-程序的使用" class="headerlink" title="实验一 Debug 程序的使用"></a>实验一 Debug 程序的使用</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>熟悉 DEBUG 程序中的命令，学会在 DEBUG 下调试运行汇编语言源程序。</li>
<li>掌握 8086/8088 的寻址方式及多字节数据的处理方法。</li>
</ol>
<span id="more"></span>

<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>利用 DEBUG 程序中的 “E” 命令，将两个多字节数 12345678H 和 FEDCBA98H 分别送入起始地址为 DS:0200H 和 DS:0204H 两个单元中。</li>
<li>分别用直接寻址方式和寄存器间接寻址方式编写程序段，实现将 DS:0200H 单元和 DS:0204H 单元中的数据相加，并将运算结果存放在 DS:0208H 单元中。</li>
</ol>
<p>要求：</p>
<p>本次实验的内容均在 DEBUG 下完成，实现数据的装入、修改、显示；汇编语言程序段的编辑、汇编和反汇编；程序的运行和结果检查。</p>
<h2 id="实验过程和程序"><a href="#实验过程和程序" class="headerlink" title="实验过程和程序"></a>实验过程和程序</h2><ol>
<li>启动 DOS 操作系统</li>
<li>运行 DEBUG 程序</li>
<li>用 “A” 命令编辑和汇编源程序</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-01/A-edit-code.png" alt="编写代码"></p>
<ol start="4">
<li>用 “U” 命令反汇编验证源程序</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-01/U-decompile.png" alt="查看反汇编"></p>
<ol start="5">
<li>程序未执行前，用 “R” 命令观察，相关寄存器的内容</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-01/R-read-reg.png" alt="查看寄存器"></p>
<ol start="6">
<li>在程序未执行前，用 “D” 命令观察 DS:0200H, DS:0204H, DS:0208H 单元的内容</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-01/D-read-data.png" alt="查看数据"></p>
<ol start="7">
<li>用 “G” 命令运行源程序</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-01/G-run.png" alt="运行程序"></p>
<ol start="8">
<li>再用 “D” 命令观察 DS:0200H ~ DS:020BH 字节单元中的内容</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-01/D-read-result.png" alt="查看结果"></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>程序运行结果：</p>
<p>AX = <u>1110</u>, BX = <u>1111</u><br>DS:0208H 四字节单元的内容：<u>10 11 11 11</u></p>
<p>试用寄存器间接寻址方式编写程序段，完成上述程序段的功能。</p>
<ol>
<li>先使用 “A” 编写代码：</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-02/A-edit-code.png" alt="编写代码"></p>
<ol start="2">
<li>“U” 查看反汇编代码</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-02/U-decompile.png" alt="查看反汇编"></p>
<ol start="3">
<li>“G” 运行</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-02/G-run.png" alt="运行程序"></p>
<ol start="4">
<li>“D” 查看数据，与上面的代码运行结果一致</li>
</ol>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/part-02/D-read-result.png" alt="查看结果"></p>
<h2 id="附加题目"><a href="#附加题目" class="headerlink" title="附加题目"></a>附加题目</h2><h3 id="第-1-题"><a href="#第-1-题" class="headerlink" title="第 1 题"></a>第 1 题</h3><p>从 DS:0000H 开始的 5 个 16 位带符号数分别记为 x, y, z, v, w，用 E 命令初始化为：540, 1, -1, 1080, 0，试求 w = (v - (x * y + z - 540)) / x</p>
<p><strong>解：</strong></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-01/U-decompile.png" alt="查看反汇编"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-01/E-edit-data.png" alt="写入数据"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-01/G-run.png" alt="运行程序"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-01/D-read-result.png" alt="查看结果"></p>
<h3 id="第-2-题"><a href="#第-2-题" class="headerlink" title="第 2 题"></a>第 2 题</h3><p>完成 BX 中 1 的个数的统计</p>
<p><strong>解：</strong></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-02/U-decompile.png" alt="查看反汇编"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-02/G-run.png" alt="运行程序"></p>
<h3 id="第-3-题"><a href="#第-3-题" class="headerlink" title="第 3 题"></a>第 3 题</h3><p>用串操作指令将 DS:0000 开始 20 个字初始化为 0DDCCH。并将这 20 个字的内容复制到其后的 20 个字里</p>
<p><strong>解：</strong></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-03/A-edit-code.png" alt="编写代码"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-03/D-read-data.png" alt="查看数据"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-01/additional-03/D-read-result.png" alt="查看结果"></p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 node-sass 遇到的问题</title>
    <url>/posts/node-js/install-node-sass/</url>
    <content><![CDATA[<h1 id="安装-node-sass-遇到的问题"><a href="#安装-node-sass-遇到的问题" class="headerlink" title="安装 node-sass 遇到的问题"></a>安装 node-sass 遇到的问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天运行一个开源项目时需要安装 node-sass，但是一直安装失败。看了一下日志，一直是在 github 下载二进制文件这一步报错，看来又是因为网络原因。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>从网上检索了一下，可以使用国内 taobao 提供的镜像，设置以下环境变量即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可根据自己的操作系统自行修改设置环境变量的命令</span></span><br><span class="line">export SASS_BINARY_SITE=http://npm.taobao.org/mirrors/node-sass</span><br></pre></td></tr></table></figure>

<p>然后就可以正常进行安装步骤了。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>node-sass</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 NPM 镜像</title>
    <url>/posts/node-js/npm-mirror/</url>
    <content><![CDATA[<h1 id="配置-NPM-镜像"><a href="#配置-NPM-镜像" class="headerlink" title="配置 NPM 镜像"></a>配置 NPM 镜像</h1><p>由于网络的原因，使用 NPM 或者 Yarn 工具安装依赖时很慢，还经常出错。好在淘宝提供了国内的镜像可以使用。</p>
<p>但是除了 NPM 镜像之外，还有许多像 node-sass、Electron 的依赖需要配置单独的镜像。我在之前的一篇笔记中记录了 node-sass 的<a href="/posts/node-js/install-node-sass/" title="配置方法">配置方法</a> ，在这里做一下汇总。</p>
<span id="more"></span>

<h2 id="NPM-镜像"><a href="#NPM-镜像" class="headerlink" title="NPM 镜像"></a>NPM 镜像</h2><h3 id="使用-nrm"><a href="#使用-nrm" class="headerlink" title="使用 nrm"></a>使用 nrm</h3><p>nrm 是一个命令行工具，可以快速的管理 NPM 镜像地址。</p>
<p>因为其内置了一些常用的镜像地址，所以免去了查找镜像地址的过程，推荐优先使用这种方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 nrm</span></span><br><span class="line">npm install -g nrm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前镜像名称</span></span><br><span class="line">nrm current</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>

<h3 id="直接设置"><a href="#直接设置" class="headerlink" title="直接设置"></a>直接设置</h3><p>除了使用 nrm 工具之外，还可以直接手动指定镜像地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<h2 id="其他常用镜像"><a href="#其他常用镜像" class="headerlink" title="其他常用镜像"></a>其他常用镜像</h2><p>这些镜像就只能通过直接指定地址的方式来使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node-sass</span></span><br><span class="line">npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Electron</span></span><br><span class="line">npm config set electron_mirror https://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>node-sass</tag>
        <tag>NPM</tag>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中使用 Socks 代理的方法</title>
    <url>/posts/python/socket-proxy/</url>
    <content><![CDATA[<h1 id="Python-中使用-Socks-代理的方法"><a href="#Python-中使用-Socks-代理的方法" class="headerlink" title="Python 中使用 Socks 代理的方法"></a>Python 中使用 Socks 代理的方法</h1><p>今天在使用 Python 编写一个工具的时候，发现不能访问谷歌的某个 API，于是尝试使用 Socks 代理来进行访问。</p>
<span id="more"></span>

<p>首先安装 <code>PySocks</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install PySocks</span><br></pre></td></tr></table></figure>

<p>然后在需要使用代理的前面添加以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socks</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用代理</span></span><br><span class="line">socks.set_default_proxy(socks.SOCKS5, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">2660</span>)</span><br><span class="line">socket.socket = socks.socksocket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询当前 IP 地址</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://api.ipify.org/?format=json&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.json())</span><br></pre></td></tr></table></figure>

<p>使用前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;ip&#x27;: &#x27;112.*.*.52&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>使用后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;ip&#x27;: &#x27;119.*.*.105&#x27;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Socks5</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 统一异常处理</title>
    <url>/posts/spring-boot/global-exception-handler/</url>
    <content><![CDATA[<h1 id="SpringBoot-统一异常管理"><a href="#SpringBoot-统一异常管理" class="headerlink" title="SpringBoot 统一异常管理"></a>SpringBoot 统一异常管理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 SpringBoot 开发接口时，经常会遇到异常，比如数据库操作错误导致的异常。如果不对这些异常进行处理，异常日志就会直接传递到前端，一方面会泄露系统内部的信息；另一方面也会影响前端判断接口调用是否成功（不是统一的响应格式）。</p>
<p>但是如果在每个接口中处理异常的话，不仅很麻烦，而且产生了大量的冗余代码，不容易维护。因此，我们可以建立一个全局的异常处理器。</p>
<span id="more"></span>

<p>SpringWeb 提供了 <code>@ControllerAdvice</code> 注解，可以用来创建统一的异常处理器。</p>
<h2 id="模拟异常"><a href="#模拟异常" class="headerlink" title="模拟异常"></a>模拟异常</h2><p>我们新建一个 <code>UserController</code>，再创建 <code>/user/login</code> 接口，直接返回一个 <code>RuntimeException</code> 来模拟异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An exception happened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时直接访问此接口会得到以下页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Whitelabel Error Page</span><br><span class="line">This application has no explicit mapping for /error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Thu Apr 23 15:53:45 CST 2020</span><br><span class="line">There was an unexpected error (type=Internal Server Error, status=500).</span><br><span class="line">an exception happened</span><br><span class="line">java.lang.RuntimeException: an exception happened</span><br><span class="line">  at com.example.demo.UserController.login(UserController.java:11)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">  at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)</span><br><span class="line">  at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)</span><br><span class="line">  at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)</span><br><span class="line">  at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)</span><br><span class="line">  at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)</span><br><span class="line">  at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)</span><br><span class="line">  at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="创建异常处理器"><a href="#创建异常处理器" class="headerlink" title="创建异常处理器"></a>创建异常处理器</h2><p>我们使用 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler</code> 来创建全局的异常处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">Message <span class="title">handleRuntimeException</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">        LOGGER.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>@ControllerAdvice</code> 注解指定了处理器的作用范围，<code>@ExceptionHandler</code> 注解指定了可以处理的异常类型。</p>
<h2 id="测试异常处理器"><a href="#测试异常处理器" class="headerlink" title="测试异常处理器"></a>测试异常处理器</h2><p>此时再访问接口就可以得到经过处理的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;4000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;An exception happened&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样既不会泄露系统运行轨迹也方便了前端调用接口。</p>
<h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>我们可以自定义异常，再利用全局异常处理器进行处理，就可以根据自己的业务情况，方便地在需要的地方直接抛出异常。</p>
<p>自定义异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(CustomException.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function">Message <span class="title">handleCustomException</span><span class="params">(CustomException e)</span> </span>&#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">&quot;这是一个自定义异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;4000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;这是一个自定义异常&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动验证参数"><a href="#自动验证参数" class="headerlink" title="自动验证参数"></a>自动验证参数</h3><p>我们可以将其和 <code>@Valid</code> 注解结合起来使用，实现自动验证请求参数。</p>
<p>定义 Bean：在需要验证的属性上添加相应的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;username 不能为空&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;password 不能为空&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动验证：使用 @Valid 注解，要求进行验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">login</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserBean user)</span> </span>&#123;</span><br><span class="line">        System.out.println(user.getUsername());</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理器：自动捕获验证异常，并处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function">Message <span class="title">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span> </span>&#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.error(e.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;4000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;password 不能为空&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的静态 HTTP 服务器</title>
    <url>/posts/tomcat/simple-static-http-server/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常会使用 HTTP 服务。也许你没听过 HTTP，但是你一定浏览过网页，而浏览器与服务器之间就是使用 HTTP 协议来通信的。这篇笔记记录了实现一个简单的静态 HTTP 服务器的过程。</p>
<span id="more"></span>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP(Hyper Text Transfer Protocol) 是一种用于 Web 服务器和客户端之前交换数据的传送协议，它使用可靠的 TCP/IP 通信协议来传递数据。</p>
<p>一般情况下，总是由客户端发送 HTTP 请求，Web 服务器处理请求之后返回一个 HTTP 响应。</p>
<h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>一个 HTTP 请求包含以下三个部分：</p>
<ul>
<li>请求方法 统一资源标识符 协议/版本</li>
<li>请求头</li>
<li>请求实体</li>
</ul>
<p>例如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8000</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">username</span>=xuewen&amp;password=pwd123</span></span><br></pre></td></tr></table></figure>

<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求的第一行包含了三个参数，分别表示请求方法、统一资源标识符、协议/版本：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<p>其中请求方法为 <code>GET</code>，统一资源标识符为 <code>/</code>，协议/版本为 <code>HTTP/1.1</code>。</p>
<p>每个 HTTP 请求都可以使用 HTTP 标准指定的请求方法之一，HTTP 1.1 支持的7中请求协议包括：</p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
<li>OPTION</li>
<li>TRACE</li>
</ul>
<p>请求资源标识符 (URI) 是 Internet 资源的完整路径。URI 通常是相对于服务器根目录的路径，通常以 <code>/</code> 开始。</p>
<p>协议/版本说明了当前请求使用的 HTTP 协议的版本。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求头指定了 HTTP 请求的一些参数，如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8000</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br></pre></td></tr></table></figure>

<p><code>Host</code> 指出了本次请求的 Web 服务器的主机名</p>
<p><code>Cache-Control</code> 用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>
<p><code>User-Agent</code> 包含了一个特征字符串，用来让 Web 服务器识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号。</p>
<p><code>Accept</code> 用来告知（服务器）客户端可以处理的内容类型。</p>
<p><code>Accept-Encoding</code> 用来说明客户端接能处理的内容编码方式，一般是压缩算法。</p>
<h3 id="请求实体"><a href="#请求实体" class="headerlink" title="请求实体"></a>请求实体</h3><p>在请求头的后面是一行空行，这个空行用来分隔请求头和请求体，即在空行的后面是本次请求的内容。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">username=xuewen&amp;password=pwd123</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>HTTP 响应与 HTTP 请求类似，也有三个组成部分：</p>
<ul>
<li>协议/版本 状态码描述</li>
<li>响应头</li>
<li>响应体</li>
</ul>
<p>例如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>SimpleHTTP/0.6 Python/3.6.8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 23 Oct 2019 12:42:06 GMT</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 23 Oct 2019 12:42:00 GMT</span><br><span class="line"></span><br><span class="line"><span class="ebnf"><span class="attribute">hello</span></span></span><br></pre></td></tr></table></figure>

<p>响应的第一行与请求类似，指明了 HTTP 协议的版本，响应的状态码 (200 表示请求成功)。</p>
<p>接下来的是响应头，与请求头类似，包含了许多参数。<br>可以点击查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">HTTP 头部信息</a></p>
<h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><p>一般情况下我们都是使用浏览器来浏览网页，浏览器会帮助我们完成发送 HTTP 请求和解析服务器返回的数据。</p>
<p>我们也可以尝试自己发送 HTTP 请求，这样可以更好的理解 HTTP 协议。</p>
<p>在发送请求时，可以使用 Java 中的 Socket 来连接服务器。</p>
<p>下面给出完整的代码：</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 Socket 对象</span></span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                    socket.getOutputStream(), <span class="keyword">true</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向服务器发送 HTTP 请求，请求的格式遵守 HTTP 协议</span></span><br><span class="line">            printWriter.println(<span class="string">&quot;GET / HTTP/1.1&quot;</span>);</span><br><span class="line">            printWriter.println(<span class="string">&quot;Host: 127.0.0.1&quot;</span>);</span><br><span class="line">            printWriter.println(<span class="string">&quot;Connection: close&quot;</span>);</span><br><span class="line">            <span class="comment">// 按照 HTTP 协议，此处空一行</span></span><br><span class="line">            printWriter.println();</span><br><span class="line">            printWriter.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取服务器返回的数据</span></span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                            socket.getInputStream()</span><br><span class="line">                    )</span><br><span class="line">            );</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">8096</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bufferedReader.ready()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">                        i = bufferedReader.read();</span><br><span class="line">                        stringBuilder.append((<span class="keyword">char</span>) i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印服务器返回的数据</span></span><br><span class="line">            System.out.println(stringBuilder.toString());</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<p>为了运行上面的程序，可以使用 Python 来开启一个 HTTP 服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 HTML 文件</span></span><br><span class="line">echo &#x27;The Server received your request!&#x27; &gt; index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启服务器</span></span><br><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure>

<p>此时运行程序，可以在控制台得到以下输出，可以看到服务器返回的数据符合 HTTP 协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/3.6.8</span><br><span class="line">Date: Tue, 29 Oct 2019 11:39:59 GMT</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-Length: 34</span><br><span class="line">Last-Modified: Tue, 29 Oct 2019 11:38:52 GMT</span><br><span class="line"></span><br><span class="line">The Server received your request!</span><br></pre></td></tr></table></figure>

<h1 id="创建-HTTP-服务器"><a href="#创建-HTTP-服务器" class="headerlink" title="创建 HTTP 服务器"></a>创建 HTTP 服务器</h1><p>这个简单的 HTTP 服务器将由三个类组成：</p>
<ul>
<li>HttpServer</li>
<li>Request</li>
<li>Response</li>
</ul>
<h2 id="HttpServer-类"><a href="#HttpServer-类" class="headerlink" title="HttpServer 类"></a>HttpServer 类</h2><p>HttpServer 表示一个 HTTP 服务器，具体代码如下：</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String webRoot = <span class="string">&quot;/servlet-learn/web-root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String response404 = <span class="string">&quot;404.html&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String shutdownCommand = <span class="string">&quot;/shutdown&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpServer httpServer = <span class="keyword">new</span> HttpServer(<span class="number">8080</span>);</span><br><span class="line">        httpServer.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="keyword">this</span>.port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已建立， http://localhost:&quot;</span> + port);</span><br><span class="line">        <span class="comment">// 等待用户连接</span></span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            Socket socket;</span><br><span class="line">            InputStream inputStream;</span><br><span class="line">            OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建用户连接</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                inputStream = socket.getInputStream();</span><br><span class="line">                outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建并解析请求对象</span></span><br><span class="line">                Request request = <span class="keyword">new</span> Request(inputStream);</span><br><span class="line">                request.parse();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建响应对象</span></span><br><span class="line">                Response response = <span class="keyword">new</span> Response(outputStream);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line">                response.sendStaticResource();</span><br><span class="line"></span><br><span class="line">                inputStream.close();</span><br><span class="line">                outputStream.flush();</span><br><span class="line">                outputStream.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getWebRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getResponse404</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<p>这个 Web 服务器可以处理客户端对指定目录中静态资源的请求，默认资源目录为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String webRoot = <span class="string">&quot;/servlet-learn/web-root&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>例如用户访问 <code>http://localhost:8080/hello.html</code> 时，程序会在 <code>webRoot</code> 目录下寻找 <code>hello.html</code> 文件并将文件返回给客户端。</p>
<p>若要关闭服务器，可以访问 <code>http://localhost:8080/shutdown</code>，该命令在程序中定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String shutdownCommand = <span class="string">&quot;/shutdown&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>当服务器建立后会调用 <code>await()</code> 方法监听用户请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpServer.await();</span><br></pre></td></tr></table></figure>

<p>在 <code>await()</code> 方法中，调用了 <code>socket.accept()</code> 来等待用户连接，并根据 <code>socket</code> 对象来获取用户的输入输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">socket = serverSocket.accept();</span><br><span class="line">inputStream = socket.getInputStream();</span><br><span class="line">outputStream = socket.getOutputStream();</span><br></pre></td></tr></table></figure>

<p>然后在根据输入输出流来创建 <code>request</code>、<code>response</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并解析请求对象</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request(inputStream);</span><br><span class="line">request.parse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应对象</span></span><br><span class="line">Response response = <span class="keyword">new</span> Response(outputStream);</span><br><span class="line">response.setRequest(request);</span><br><span class="line"><span class="comment">// 发送请求的文件资源</span></span><br><span class="line">response.sendStaticResource();</span><br></pre></td></tr></table></figure>

<p>最后服务器关闭连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputStream.close();</span><br><span class="line">outputStream.flush();</span><br><span class="line">outputStream.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<h2 id="Request-类"><a href="#Request-类" class="headerlink" title="Request 类"></a>Request 类</h2><p>Request 类用于处理用户的请求，主要代码如下：</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        parseHeader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 代码省略，见下文</span></span><br><span class="line">        <span class="comment">// 代码省略，见下文</span></span><br><span class="line">        <span class="comment">// 代码省略，见下文</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> version;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<p>Request 类中保存了用户的输入流。在 <code>parse()</code> 方法中解析输入流来构建完整的 <code>request</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    parseHeader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">            inputStream</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    String line = bufferedReader.readLine();</span><br><span class="line">    String[] ags = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.method = ags[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.uri = ags[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.version = ags[<span class="number">2</span>];</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;请求头： %s, %s, %s&quot;</span>, method, uri, version));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Response-类"><a href="#Response-类" class="headerlink" title="Response 类"></a>Response 类</h2><p>Response 类用于处理给用户的响应。主要的代码为根据 Request 对象来查找文件并写入到 Socket 的输出流中去，即发送给用户。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendStaticResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">        String uri = <span class="keyword">this</span>.request.getUri();</span><br><span class="line">        String webRoot = HttpServer.getWebRoot();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uri.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            uri = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HttpServer.shutdownCommand.equals(uri)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到关闭指令，正在关闭服务器！&quot;</span>);</span><br><span class="line">            HttpServer.shutdown = <span class="keyword">true</span>;</span><br><span class="line">            uri = HttpServer.shutdownCommand + <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(webRoot, uri);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(HttpServer.getWebRoot(), HttpServer.getResponse404());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> count = fileInputStream.read(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">while</span> (count != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.outputStream.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">                count = fileInputStream.read(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<p>在处理 Request 的时候，可以根据 URI 进行判断：</p>
<ul>
<li>如果 URI 为 <code>/</code>，则返回 <code>index.html</code> 文件</li>
<li>如果 URI 为 <code>/shutdown</code>，则关闭服务器，并返回 <code>shutdown.html</code> 文件</li>
</ul>
<h2 id="测试客户端和服务器"><a href="#测试客户端和服务器" class="headerlink" title="测试客户端和服务器"></a>测试客户端和服务器</h2><p>在终端运行 <code>HttpServer</code>，使用 <code>SendRequest</code> 进行请求，可以得到以下结果：</p>
<p>服务端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">服务器已建立， http://localhost:8080</span><br><span class="line">--------------------------------</span><br><span class="line">请求头： GET, /, HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Index File.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这个实验中学到了一个简单的 Web 服务器是如何工作的。虽然功能很简单，但是有助于理解客户端和服务器之间使用 HTTP 通信的细节。</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTTP</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg 的常用命令</title>
    <url>/posts/tool/ffmpeg/</url>
    <content><![CDATA[<h1 id="FFmpeg-的常用命令"><a href="#FFmpeg-的常用命令" class="headerlink" title="FFmpeg 的常用命令"></a>FFmpeg 的常用命令</h1><h2 id="裁剪视频"><a href="#裁剪视频" class="headerlink" title="裁剪视频"></a>裁剪视频</h2><p>裁剪视频中的片段：</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -ss [start] -i input.mp4 -t [duration] -c copy output.mp4</span><br><span class="line">ffmpeg -ss [start] -i input.mp4 -to [end] -c copy -copyts output.mp4</span><br><span class="line">ffmpeg -i input.mp4 -ss [start] -t [duration] output.mp4</span><br><span class="line">ffmpeg -i input.mp4 -ss [start] -to [end] output.mp4</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>当 -ss 在 -i 之前时，-to 选项相当于 -t 选项，可以使用 -copyts 来保证 -to 原有的效果</li>
<li>当 -ss 在 -i 之前时，会在输入文件中进行定位，此时 -avoid_negative_ts 会生效，即会将视频时间扩展到关键帧，但是裁剪的时间不准确</li>
<li>当 -ss 在 -i 之后时，-avoid_negative_ts 不生效，可以实现精确裁剪，但是可能会产生部分空白视频，建议启用编码器</li>
</ol>
<h2 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h2><p>提取字幕：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mkv -map 0:s:0 sub.srt</span><br></pre></td></tr></table></figure>

<h2 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h2><p>查看视频中关键帧信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看关键帧的所有信息</span></span><br><span class="line">ffprobe -loglevel error -skip_frame nokey -select_streams v:0 -show_frames input.mp4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看关键帧的时间戳</span></span><br><span class="line">ffprobe -loglevel error -skip_frame nokey -select_streams v:0 -show_entries frame=pkt_pts_time -of csv=print_section=0 input.mp4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>使用代理访问 Git 服务</title>
    <url>/posts/tool/git-with-proxy/</url>
    <content><![CDATA[<h1 id="使用代理访问-Git-服务"><a href="#使用代理访问-Git-服务" class="headerlink" title="使用代理访问 Git 服务"></a>使用代理访问 Git 服务</h1><p>由于网络的原因，访问 Github 很慢，每次拉取或者克隆代码时都要等很久，还经常失败。下面介绍如何利用代理来访问 Git 服务，让下载速度飞起！</p>
<p>Git 的仓库地址有两种协议，分别是 HTTP(S) 和 SSH，下面分两种情况介绍，各取所需即可。</p>
<span id="more"></span>

<h2 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP(S) 协议"></a>HTTP(S) 协议</h2><p>以下形式的链接，使用的就是 HTTPS 协议：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xuewenG/sync-play.git</span><br></pre></td></tr></table></figure>

<p>使用 HTTP(S) 协议时，直接使用 Git 提供的命令设置代理即可（假设客户端在本地端口 <code>10808</code> 上有一个 Socks5 代理服务）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 代理所有 HTTP(S) 请求</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:10808</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只代理 https://github.com 的请求</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:10808</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消 HTTP(S) 代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

<h2 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h2><p>以下形式的链接则是 SSH 协议：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:xuewenG/sync-play.git</span><br></pre></td></tr></table></figure>

<p>通过 SSH 协议的时候，直接配置 SSH 代理即可，可以参考这篇笔记——<a href="/posts/linux/ssh-with-proxy/" title="使用代理连接远程主机">使用代理连接远程主机</a>。</p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>Socks5</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>HFUT 校园网自动登录脚本</title>
    <url>/posts/tool/hfut-auto-login/</url>
    <content><![CDATA[<h1 id="HFUT-校园网自动登录脚本"><a href="#HFUT-校园网自动登录脚本" class="headerlink" title="HFUT 校园网自动登录脚本"></a>HFUT 校园网自动登录脚本</h1><p>学校的校园网每次开机都需要重新登录才能使用，很麻烦。这个脚本可以实现自动登录校园网，只需将其加入到开机自启动中即可。</p>
<span id="more"></span>

<p>这是自动登录脚本，无法用于破解校园网，使用的前提是已经有可用的校园网账号！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换成你的账号信息</span></span><br><span class="line">USERNAME = <span class="string">&#x27;2017000000&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;your_password&#x27;</span></span><br><span class="line"></span><br><span class="line">test_urls = [<span class="string">&#x27;http://koolshare.cn/portal.php&#x27;</span>, <span class="string">&#x27;http://www.sosoapi.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">count_success_url = <span class="number">0</span></span><br><span class="line">count_fail_url = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="keyword">for</span> test_url <span class="keyword">in</span> test_urls:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;url: &#x27;</span>, test_url)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        cdn_r = s.get(test_url, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> cdn_r.text.find(<span class="string">&#x27;top.self.location.href&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">            count_fail_url = count_fail_url + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;try &#123;0&#125;, failed.&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count_success_url = count_success_url + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;try &#123;0&#125;, succeed.&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;success: &#x27;</span>, count_success_url, <span class="string">&#x27;, fail_url: &#x27;</span>, count_fail_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count_success_url &gt; count_fail_url:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;您已经登录！&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到用于初始化Session的地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在获取初始化页面地址: &#x27;</span>)</span><br><span class="line">cdn_r = s.get(<span class="string">&#x27;http://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&#x27;</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">re_match = re.search(<span class="string">&#x27;http\S*\&#x27;&#x27;</span>, cdn_r.text)</span><br><span class="line"><span class="keyword">if</span> re_match <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;获取初始化地址失败，可能已经登录！&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line">session_url = re_match.group()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(session_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Session</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在建立 Session: &#x27;</span>)</span><br><span class="line">session = s.get(session_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始登录</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始登录&#x27;</span>)</span><br><span class="line">r = s.post(<span class="string">&#x27;http://210.45.240.245/post.php&#x27;</span>,</span><br><span class="line">           data=&#123;<span class="string">&#x27;username&#x27;</span>: USERNAME, <span class="string">&#x27;password&#x27;</span>: PASSWORD, <span class="string">&#x27;0MKKey&#x27;</span>: <span class="string">&#x27;%B5%C7+%C2%BC&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>HFUT</tag>
        <tag>校园网</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/posts/java/hashmap/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>HashMap</code> 是一种 <code>key-value</code> 结构的容器。</p>
<p>HashMap 在 JDK 1.7 和 JDK 1.8 中的实现有所不同，下面就这两种版本分别进行学习。</p>
<span id="more"></span>

<h1 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h1><h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><p>首先列举出 HashMap 中一些主要的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量的取值, 必须为 2 的 n 次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16, Also Known As 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子的取值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 中实际存放的 key-value 的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下次对 table 进行扩容的阈值(threshold = capacity * load factor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>HashMap 中有一个 <code>Entry</code> 内部类，用于存放 Map 中元素的相关信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 用户设置的 key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户存放的 value</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于实现链表数据结构</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 key 的 hash</span></span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 HashMap 的一些属性不难看出，HashMap 中采用<strong>数组 + 链表</strong>的数据结构。数组中的一个个位置被称为 <code>bucket</code>，每一个 bucket 都有唯一的序号与之对应。</p>
<p>也就是说，当不同的 key 在数组中的位置产生冲突时，HashMap 会采取链表的方式来解决冲突。</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HahsMap 中提供了三种构造函数，分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看出在创建 HashMap 时，可以直接指定初始容量和负载因子来调用第三个构造函数。</p>
<p>也可以不提供相关的参数，也就是使用第一个或者第二个构造函数，HashMap 会使用默认参数去调用第三个构造函数。</p>
<p>在构造函数中，HashMap 会对参数进行校验，然后初始化一些属性。<strong>但是此时不会创建 table。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();     <span class="comment">// HashMap 中的 init 方法什么也没做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>put 方法是常用的两个方法之一，用于将 key-value 存入到 HashMap 中。</p>
<p>HashMap 在初始化 table 属性上，采用了<strong>懒初始化</strong>的策略。构造函数中并没有初始化 table，而是在使用 put 操作时，对 table 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 table 是否初始化</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 key 是否为 null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 操作有以下步骤：</p>
<ol>
<li>判断 table 是否为空，若空则初始化</li>
<li>判断 key 是否为 <code>null</code>，若为 <code>null</code> 则使用 putForNullKey 方法来进行接下来的操作，<strong>说明 HashMap 支持 key 为 <code>null</code></strong></li>
<li>计算 key 的 hash</li>
<li>根据 hash 计算 key 在 table 中的下标</li>
<li>遍历相应下标位置的链表中的 Entry，如果 Entry 中的 key 和 给定的 key 重复，则覆盖原来的 value，并返回 oldValue</li>
<li>如果进行到这一步，则说明没有重复的 key，则需要创建一个 Entry 来插入到链表中去</li>
<li>最后返回 <code>null</code>，说明当前 key 没有重复</li>
</ol>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p>get 方法是 HashMap 中的另外一个常用方法，用于获取指定的 key 对应的 value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 get 方法中，先对 key 进行了判断，若 key 不为 <code>null</code>，则调用 getEntry 方法来查找相应的 Entry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">            e != <span class="keyword">null</span>;</span><br><span class="line">            e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getEntry 方法中，用以下步骤来查找相应的 Entry。</p>
<ol>
<li>根据 HashMap 中元素的数量来进行快速的判断。若 HashMap 为空，则直接返回 <code>null</code></li>
<li>计算 key 的 hash</li>
<li>根据 hash 获取对应的 <code>bucket</code>，并遍历链表，查找并返回目标 Entry</li>
<li>若进行到这一步，则说明没有查找到对应的 Entry，应该返回 <code>null</code></li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>前面学习了 HashMap 中的主要方法，那么在这些方法中用到的一些工具方法是如何实现的呢？</p>
<p>下面学习这些更细节的方法，对应了 HashMap 的其他功能，如计算 hash、计算 <code>bucket</code> 序号、扩容等。</p>
<h3 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h3><p>hash() 方法是 HashMap 的关键方法，被用来计算 key 的 hash。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 hash 方法中，采用了以下步骤来计算 key 的 hash:</p>
<ol>
<li>如果 hashSeed 不为 <code>0</code> 并且 key 是 <code>String</code> 类型，则使用 <code>sun.misc.Hashing.stringHash32</code> 来计算 hash，并直接返回</li>
<li>调用 key 的 hashCode</li>
<li>对 hashCode 进行位运算，最终返回结果</li>
</ol>
<p>在 hash() 方法中，进行了多次位运算，目的是使 hash 结果更加随机，减少冲突。</p>
<h3 id="indexFor-方法"><a href="#indexFor-方法" class="headerlink" title="indexFor 方法"></a>indexFor 方法</h3><p>indexFor 方法用于计算 hash 对应的 bucket 序号。这个方法非常简单，其实际上就相当于拿 hash 对 table 的长度取模。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现时为了提高效率，使用了<strong>位运算</strong>代替取模的运算。能这么做的原因是 HashMap 规定了 table 的长度必须为 2 的次方，也就是说 <strong>a % b = a &amp; (b - 1)，a = 2 ^ n</strong>。</p>
<h3 id="addEntry-方法"><a href="#addEntry-方法" class="headerlink" title="addEntry 方法"></a>addEntry 方法</h3><p>addEntry() 方法用于创建并向 bucket 中添加一个 Entry，也就是包含了 key-value、hash、nextEntry 信息的对象。在 put 方法中，如果 key 没有重复，就会调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中先判断了当前 HashMap 是否需要扩容，再将 Entry 插入。</p>
<p>在扩容前必须满足必须满足以下两点条件：</p>
<ol>
<li>HashMap 中已有的元素数量大于等于扩容阈值</li>
<li><strong>被添加的 Entry 所在的 bucket 没有元素</strong></li>
</ol>
<p>其中，比较容易被忽略的是<strong>条件 2</strong>。这点也很容易理解，扩容的原因是防止每个 bucket 下的链表过长导致降低查询效率。但是如果要<strong>向空的 bucket 中插入 Entry，显然不会降低查询效率</strong>，因此可以延迟扩容时机。</p>
<h3 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer 方法"></a>transfer 方法</h3><p>对 HashMap 扩容时，会先在 resize 方法中创建一个新的 table，再调用 tansfer 方法将原来的 Entry 转移到 newTable 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出在这个方法中，有两层循环。第一层循环遍历了 table 中的 bucket，第二层循环遍历了每个 bucket 下的链表中的 Entry。</p>
<p>在遍历到 Entry 时，会<strong>根据参数 rehash 来判断是否重新计算 hash</strong>，接着再计算该 Entry 在 newTable 中的 bucket 序号。同时<strong>将该 Entry 插入到 bucket 的链表头部</strong>。</p>
<p>如果没有经过重新计算 hash 的话，那么一个元素在新的 bucket 中的下标只有两种可能。</p>
<h2 id="多线程下的问题"><a href="#多线程下的问题" class="headerlink" title="多线程下的问题"></a>多线程下的问题</h2><p>首先要强调的是我们不应该在多线程下使用 HashMap。因为 HashMap 在多线程下可能会遇到同步的问题，这一点在 JDK 的文档中也提到了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * If multiple threads access a hash map concurrently, and at least one of</span></span><br><span class="line"><span class="comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span></span><br><span class="line"><span class="comment"> * synchronized externally.  (A structural modification is any operation</span></span><br><span class="line"><span class="comment"> * that adds or deletes one or more mappings; merely changing the value</span></span><br><span class="line"><span class="comment"> * associated with a key that an instance already contains is not a</span></span><br><span class="line"><span class="comment"> * structural modification.)  This is typically accomplished by</span></span><br><span class="line"><span class="comment"> * synchronizing on some object that naturally encapsulates the map.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>具体来说， HashMap 在多线程下存在出现无限循环的可能。</p>
<p>让我们回到 transfer 方法中，在这个方法里会将 HashMap 中已有的 Entry 移动到 newTable 中。值得注意的是，<strong>在移动时采用了头插法</strong>，也就是说在移动完成后，每个 bucket 下的链表都会变成<strong>原来的倒序</strong>。</p>
<p>假设以下场景：</p>
<p>有两个线程共享了同一个 HashMap 实例。在某时刻，线程一认为 HashMap 需要扩容，假设线程一正在对含有三个 Entry 的 链表进行操作，在while 循环中<strong>第一个语句（如下）刚执行完成后，就被线程调度系统挂起了</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure>

<p>此时线程二也发现了需要扩容，<strong>假设线程二顺利完成了扩容操作</strong>，线程二完成对 HashMap 的操作后又运行了一段时间也被挂起了。<strong>这时看似没有问题，但是其实已经给线程一埋下了坑</strong>。</p>
<p>轮到线程一继续执行时，该线程操作的链表已经被倒序了，也就是说之前记录的 <code>next</code> 和 <code>e</code> 的值已经是不正确的了。当该线程继续完成转移操作后，链表中就会出现<strong>环</strong>。</p>
<p>当线程一完成扩容后，HashMap 的结构已经存在了错误，此时如果使用 get 方法查询某个 key，而这个 key 对应的 bucket 下的链表中又刚好存在环，那么就有无限循环的可能。</p>
<h1 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h1><p>在 JDK 1.7 中使用了链表来解决冲突的问题。但是当冲突过多时，就会导致链表过长，影响查询效率。因此在 JDK 1.8 中采用了<strong>红黑树</strong>对这个问题进行了优化。</p>
<p>此外，JDK 1.8 中还添加了 <strong>putIfAbsent</strong> 等方法，下面的分析中也会提到。</p>
<h2 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h2><p>与之前的版本相比，主要多了几个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将链表树化的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 将树还原成链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 树化时 HashMap 中至少含有 bucket 的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>增加树化的阈值，也就是当一个 bucket 中的元素达到这个阈值时，就会将链表转换为红黑树。</p>
<p>这里的 TREEIFY_THRESHOLD 是根据 bucket 内的元素个数的概率分布来确定的。一个 bucket 内的元素个数满足泊松分布，大致概率如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 0:    0.60653066</span></span><br><span class="line"><span class="comment">* 1:    0.30326533</span></span><br><span class="line"><span class="comment">* 2:    0.07581633</span></span><br><span class="line"><span class="comment">* 3:    0.01263606</span></span><br><span class="line"><span class="comment">* 4:    0.00157952</span></span><br><span class="line"><span class="comment">* 5:    0.00015795</span></span><br><span class="line"><span class="comment">* 6:    0.00001316</span></span><br><span class="line"><span class="comment">* 7:    0.00000094</span></span><br><span class="line"><span class="comment">* 8:    0.00000006</span></span><br><span class="line"><span class="comment">* more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看见一个 bucket 内的元素大于 8 的概率已经很小了，所以此处选择了 8 作为树化的阈值。</p>
<p>对应的还有一个还原成链表的阈值 UNTREEIFY_THRESHOLD，这个阈值比树化的阈值小了 2，是为了<strong>防止频繁地在红黑树和链表之间转换</strong>。</p>
<p>最后还有一个 MIN_TREEIFY_CAPACITY，这个属性在 treeifyBin 中用到了。如果当前 table 中的 bucket 没有达到这个值，那么将会对 table 进行扩容，而不是直接进行树化的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 JDK 1.8 中，将原来的 Entry 改名为 Node，同时又添加了用于红黑树的数据结构 TreeNode。</p>
<h2 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h3><div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<p>JDK 1.8 中的 put 方法复杂了很多，主要是按照以下的步骤进行：</p>
<ol>
<li>判断 table 是否需要初始化（使用 resize() 进行初始化）</li>
<li>根据 hash 计算桶的位置，并判断桶是否为空，若是则直接创建新的 Node 插入并跳到第 7 步</li>
<li>判断 bucket 中的第一个 Node 的 key 与提供的 key 是否相等，相等则记录这个 Node 的引用并跳到第 6 步</li>
<li>判断第一个 Node 是否为 TreeNode 实例，也就是 bucket 中是否为红黑树，若是则调用 putTreeVal() 来写入数据，并跳转到第 6 步（调用 putTreeVal() 时，<strong>若提供的 key 在红黑树中已存在，则并不会修改原 TreeNode 中的 value，而是得到这个 TreeNode 的引用</strong>；若不存在，才会插入一个新的 TreeNode 并得到 null）</li>
<li>遍历链表，若提供的 key 在链表中已存在，则不会修改数据，得到一个已存在的 Node 的引用；若提供的 key 在链表中不存在，才会插入一个新的 Node 并得到 null，然后判断是否需要将链表进行树化</li>
<li>若在第3、4、5步中得到的是 null，则说明提供的 key 在 map中并不存在，可以直接跳到第 7 步；若得到的是一个 Node 的引用，就说明提供的 key 在 map 中已经存在，继续对 onlyIfAbsent 和 oldValue 进行判断，<strong>只有当 onlyIfAbsent 为 true 且 oldValue 不为 null时，才不会修改数据</strong>，最后直接返回 oldValue</li>
<li>判断是否需要对 map 进行扩容，最后返回 null</li>
</ol>
<p>可以看到 JDK 1.8 中的 put 方法和 putIfAbsent 方法都是调用了 putVal 方法。</p>
<h3 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 方法中也是区分链表和红黑树进行查找的，具体步骤如下：</p>
<ol>
<li>先快速判断 table 是否为空、对应 bucket 是否为空</li>
<li>判断 bucket 中的第一个 Node 是否为要查找的，若是则直接返回</li>
<li>判断 bucket 中的是否为红黑树，若是，则按照红黑树的方式进行查找并返回</li>
<li>遍历链表中的 Node，若找到结果则返回</li>
<li>进行到这一步则说明没有查找到，返回 null</li>
</ol>
<h2 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="hash-方法-1"><a href="#hash-方法-1" class="headerlink" title="hash 方法"></a>hash 方法</h3><p>JDK 1.8 中的 hash 方法相比 1.7 中的要简化了不少，但是依然保留了将 hashcode 的高位参与运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h3><p>JDK 1.8 中的 resize 方法的改动也很大，主要变化有以下两点：</p>
<ul>
<li>添加了对树形 bucket 的扩容</li>
<li>对链表进行扩容时，<strong>保留了链表的顺序</strong></li>
</ul>
<p>在进行扩容时，链表内的元素会保持原来的顺序，这样不会导致 JDK 1.7 中的无限循环，但是要<strong>注意 HashMap 依然不是线程安全的</strong>。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

            </div>
          </div>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>实验三 子程序、宏与中断程序设计</title>
    <url>/posts/masm/experiment-03/</url>
    <content><![CDATA[<h1 id="实验三-子程序、宏与中断程序设计"><a href="#实验三-子程序、宏与中断程序设计" class="headerlink" title="实验三 子程序、宏与中断程序设计"></a>实验三 子程序、宏与中断程序设计</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>掌握子程序、宏和中断程序的设计方法。</li>
<li>熟悉在 PC 机上建立、汇编、连接、调试和运行 8086/8088 汇编语言程序的过程。</li>
</ol>
<span id="more"></span>

<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>编写一个子程序计算 z = f (x, y) = x / y + x - y（x, y, z 有符号数内存字数）。要求通过堆栈传送输入参数，输出参数通过 AX 传递。(要求有输入和输出，且有提示)。</li>
<li>编写一个宏，求三个数的最大数，原型为：MAX3 x, y, z, min，最大值要求输出。</li>
<li>挂接 1CH 中断，正计时 90 秒后退出。要求屏幕显示 0 ~ 89 的秒数。</li>
</ol>
<h2 id="实验过程和程序"><a href="#实验过程和程序" class="headerlink" title="实验过程和程序"></a>实验过程和程序</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><p>编写一个子程序计算 z = f (x, y) = x / y + x - y（x, y, z 有符号数内存字数）。要求通过堆栈传送输入参数，输出参数通过 AX 传递。(要求有输入和输出，且有提示)。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; function.asm</span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        xMsg    db  &#x27;enter x:&#x27;, &#x27;$&#x27;</span><br><span class="line">        yMsg    db  &#x27;enter y:&#x27;, &#x27;$&#x27;</span><br><span class="line">        zMsg    db  &#x27;f(x, y) = x / y + x - y = $&#x27;</span><br><span class="line">        xStr    db  20, ?, 20  dup(&#x27;$&#x27;)</span><br><span class="line">        yStr    db  20, ?, 20  dup(&#x27;$&#x27;)</span><br><span class="line">        zStr    db  20  dup(&#x27;$&#x27;)</span><br><span class="line">        x       dw  0</span><br><span class="line">        y       dw  0</span><br><span class="line">        z       dw  0</span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data, ss:stack</span><br><span class="line">start:</span><br><span class="line">        ; init segment register</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line"></span><br><span class="line">        ; 提示输入 x</span><br><span class="line">        lea     dx, xMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 读取 x</span><br><span class="line">        lea     dx, xStr</span><br><span class="line">        mov     ah, 0aH</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 提示输入 y</span><br><span class="line">        lea     dx, yMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 读取 y</span><br><span class="line">        lea     dx, yStr</span><br><span class="line">        mov     ah, 0aH</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 转换 xStr</span><br><span class="line">        lea     ax, xStr</span><br><span class="line">        adc     ax, 02H     ; 获取字符串首地址</span><br><span class="line">        push    ax</span><br><span class="line">        xor     ax, ax</span><br><span class="line">        mov     al, xStr[1] ; 获取字符串位数</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr    strToNumber</span><br><span class="line">        add     sp, 4       ; 平衡堆栈</span><br><span class="line">        mov     x, ax</span><br><span class="line"></span><br><span class="line">        ; 转换 yStr</span><br><span class="line">        lea     ax, yStr</span><br><span class="line">        adc     ax, 02H     ; 获取字符串首地址</span><br><span class="line">        push    ax</span><br><span class="line">        xor     ax, ax</span><br><span class="line">        mov     al, yStr[1] ; 获取字符串位数</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr    strToNumber</span><br><span class="line">        add     sp, 4       ; 平衡堆栈</span><br><span class="line">        mov     y, ax</span><br><span class="line"></span><br><span class="line">        ; 计算 f(x, y)</span><br><span class="line">        mov     ax, x</span><br><span class="line">        push    ax</span><br><span class="line">        mov     ax, y</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr     cal     ; 调用计算子过程</span><br><span class="line">        add     sp, 4               ; 平衡堆栈</span><br><span class="line"></span><br><span class="line">        ; 将结果转换为 str</span><br><span class="line">        push    ax</span><br><span class="line">        lea     ax, zStr</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr    numberToStr</span><br><span class="line">        add     sp, 4               ; 平衡堆栈</span><br><span class="line"></span><br><span class="line">        ; 显示结果</span><br><span class="line">        lea     dx, zMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        lea     dx, zStr</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ; Exit</span><br><span class="line">        mov     ax, 4c00H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; 计算 (x / y + x - y) 的通用过程</span><br><span class="line">        ; 入口参数：调用子程序前按顺序压入 x, y</span><br><span class="line">        ; 出口参数：AX = 计算结果</span><br><span class="line">cal     proc far</span><br><span class="line">        push    bp</span><br><span class="line">        mov     bp, sp</span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line"></span><br><span class="line">        mov     bx, [bp + 6]</span><br><span class="line">        mov     cx, [bp + 8]</span><br><span class="line">        mov     ax, cx</span><br><span class="line">        xor     dx, dx</span><br><span class="line">        div     bx</span><br><span class="line">        add     ax, cx</span><br><span class="line">        sub     ax, bx</span><br><span class="line"></span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     bp</span><br><span class="line">        ret</span><br><span class="line">cal     endp</span><br><span class="line"></span><br><span class="line">        ; 字符串转数值的通用过程</span><br><span class="line">        ; 入口参数：调用前按顺序压入字符串首地址，字符个数</span><br><span class="line">        ; 出口参数：转换结果保存在 AX 中</span><br><span class="line">strToNumber proc far</span><br><span class="line">        push    bp</span><br><span class="line">        mov     bp, sp</span><br><span class="line"></span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line">        push    dx</span><br><span class="line">        push    si</span><br><span class="line">        ; ax 不需要压入</span><br><span class="line"></span><br><span class="line">        mov     cx, [bp + 6]    ; 字符个数</span><br><span class="line">        mov     si, [bp + 8]    ; 字符串首地址</span><br><span class="line">        mov     ch, 0</span><br><span class="line">        ; dec     cl</span><br><span class="line"></span><br><span class="line">        ; 打印该字符串</span><br><span class="line">        ; mov     dx, si</span><br><span class="line">        ; mov     ah, 09H</span><br><span class="line">        ; int     21H</span><br><span class="line">        ; call    newLine</span><br><span class="line"></span><br><span class="line">        ; 显示字符串位数</span><br><span class="line">        ; mov     dl, cl</span><br><span class="line">        ; mov     ah, 02H</span><br><span class="line">        ; adc     dl, &#x27;0&#x27;</span><br><span class="line">        ; int     21H</span><br><span class="line">        ; call    newLine</span><br><span class="line"></span><br><span class="line">        xor     ax, ax      ; 将 ax 清零，用于保存转换结果</span><br><span class="line">        xor     dx, dx      ; dx 用于暂存每一位字符</span><br><span class="line">        xor     bx, bx      ; bx 用于存放乘数 10</span><br><span class="line">        mov     bl, 0aH</span><br><span class="line"></span><br><span class="line">    convertNum:</span><br><span class="line">        mul     bx          ; 将 ax 乘以 10</span><br><span class="line">        mov     dl, [si]</span><br><span class="line">        sub     dl, &#x27;0&#x27;     ; dh 为 0</span><br><span class="line">        add     ax, dx</span><br><span class="line">        inc     si</span><br><span class="line">        loop    convertNum</span><br><span class="line"></span><br><span class="line">        pop     si</span><br><span class="line">        pop     dx</span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     bp</span><br><span class="line">        ret</span><br><span class="line">strToNumber endp</span><br><span class="line"></span><br><span class="line">        ; 将数值转换为字符串的通用方法</span><br><span class="line">        ; 入口参数： 按顺序压入数值、目的字符串首地址</span><br><span class="line">        ; 出口参数： 无</span><br><span class="line">numberToStr proc far</span><br><span class="line">        push    bp</span><br><span class="line">        mov     bp, sp</span><br><span class="line"></span><br><span class="line">        push    ax</span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line">        push    dx</span><br><span class="line">        push    si</span><br><span class="line"></span><br><span class="line">        mov     ax, [bp + 8]    ; 取出数值</span><br><span class="line">        mov     si, [bp + 6]    ; 取出目的地址</span><br><span class="line">        mov     bx, 0aH         ; 用于保存 10</span><br><span class="line"></span><br><span class="line">        mov     dx, ax          ; 保存 ax</span><br><span class="line">        xor     cx, cx          ; 用于保存字符串的长度</span><br><span class="line">    getLength:</span><br><span class="line">        inc     cx</span><br><span class="line">        div     bl</span><br><span class="line">        xor     ah, ah</span><br><span class="line">        cmp     ax, 0</span><br><span class="line">        jnz     getLength</span><br><span class="line"></span><br><span class="line">        mov     ax, dx          ; 恢复 ax</span><br><span class="line"></span><br><span class="line">        dec     cx</span><br><span class="line">        add     si, cx          ; 将 si 指向字符串的末尾</span><br><span class="line"></span><br><span class="line">    convertStr:</span><br><span class="line">        xor     dx, dx</span><br><span class="line">        div     bx              ; dx.ax / bx   余数在 dx， 商在 ax</span><br><span class="line">        add     dx, &#x27;0&#x27;</span><br><span class="line">        mov     [si], dl</span><br><span class="line">        dec     si</span><br><span class="line">        cmp     ax, 0</span><br><span class="line">        jnz     convertStr</span><br><span class="line">        </span><br><span class="line">        pop     si</span><br><span class="line">        pop     dx</span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     ax</span><br><span class="line">        pop     bp</span><br><span class="line">        ret</span><br><span class="line">numberToStr endp</span><br><span class="line"></span><br><span class="line">        ; 换行的通用过程</span><br><span class="line">newLine proc</span><br><span class="line">        push    ax</span><br><span class="line">        push    dx</span><br><span class="line"></span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        pop     dx</span><br><span class="line">        pop     ax</span><br><span class="line">        ret</span><br><span class="line">newLine endp</span><br><span class="line"></span><br><span class="line">code    ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><p>编写一个宏，求三个数的最大数，原型为：MAX3 x, y, z, min，最大值要求输出。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; max3.asm</span><br><span class="line"></span><br><span class="line">        ; 获取两个数中较大的数的宏</span><br><span class="line">        ; 入口参数： num1, num2</span><br><span class="line">        ; 出口参数： AX = max(num1, num2)</span><br><span class="line">max2    macro       num1, num2</span><br><span class="line">        local   bigFlag, endFlag</span><br><span class="line">        push    dx</span><br><span class="line">        mov     dx, num1</span><br><span class="line">        cmp     dx, num2</span><br><span class="line">        jnb     bigFlag</span><br><span class="line">        mov     ax, num2</span><br><span class="line">        jmp     endFlag</span><br><span class="line">bigFlag:</span><br><span class="line">        mov     ax, dx</span><br><span class="line">endFlag:</span><br><span class="line">        pop     dx</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">        ; 获取三个数中较大的数的宏</span><br><span class="line">        ; 入口参数： num1, num2, num3</span><br><span class="line">        ; 出口参数： AX = max(num1, num2, num3)</span><br><span class="line">max3    macro       mnum1, mnum2, mnum3</span><br><span class="line">        max2    mnum1, mnum2</span><br><span class="line"></span><br><span class="line">        max2    ax, mnum3</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        x       dw      0</span><br><span class="line">        y       dw      0</span><br><span class="line">        z       dw      0</span><br><span class="line">        xMsg    db      &#x27;enter x:$&#x27;</span><br><span class="line">        yMsg    db      &#x27;enter y:$&#x27;</span><br><span class="line">        zMsg    db      &#x27;enter z:$&#x27;</span><br><span class="line">        rMsg    db      &#x27;the bigest num is $&#x27;</span><br><span class="line">        xStr    db      20, ?, 20 dup(&#x27;$&#x27;)</span><br><span class="line">        yStr    db      20, ?, 20 dup(&#x27;$&#x27;)</span><br><span class="line">        zStr    db      20, ?, 20 dup(&#x27;$&#x27;)</span><br><span class="line">        result  db      20 dup(&#x27;$&#x27;)</span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data, ss:stack</span><br><span class="line">start:</span><br><span class="line">        ; init segment register</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line"></span><br><span class="line">        ; 提示输入 x</span><br><span class="line">        lea     dx, xMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 读取 x</span><br><span class="line">        lea     dx, xStr</span><br><span class="line">        mov     ah, 0aH</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 提示输入 y</span><br><span class="line">        lea     dx, yMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 读取 y</span><br><span class="line">        lea     dx, yStr</span><br><span class="line">        mov     ah, 0aH</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 提示输入 z</span><br><span class="line">        lea     dx, zMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 读取 z</span><br><span class="line">        lea     dx, zStr</span><br><span class="line">        mov     ah, 0aH</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line"></span><br><span class="line">        ; 转换 xStr</span><br><span class="line">        lea     ax, xStr</span><br><span class="line">        adc     ax, 02H     ; 获取字符串首地址</span><br><span class="line">        push    ax</span><br><span class="line">        xor     ax, ax</span><br><span class="line">        mov     al, xStr[1] ; 获取字符串位数</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr    strToNumber</span><br><span class="line">        add     sp, 4       ; 平衡堆栈</span><br><span class="line">        mov     x, ax</span><br><span class="line"></span><br><span class="line">        ; 转换 yStr</span><br><span class="line">        lea     ax, yStr</span><br><span class="line">        adc     ax, 02H     ; 获取字符串首地址</span><br><span class="line">        push    ax</span><br><span class="line">        xor     ax, ax</span><br><span class="line">        mov     al, yStr[1] ; 获取字符串位数</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr    strToNumber</span><br><span class="line">        add     sp, 4       ; 平衡堆栈</span><br><span class="line">        mov     y, ax</span><br><span class="line"></span><br><span class="line">        ; 转换 zStr</span><br><span class="line">        lea     ax, zStr</span><br><span class="line">        adc     ax, 02H     ; 获取字符串首地址</span><br><span class="line">        push    ax</span><br><span class="line">        xor     ax, ax</span><br><span class="line">        mov     al, zStr[1] ; 获取字符串位数</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr    strToNumber</span><br><span class="line">        add     sp, 4       ; 平衡堆栈</span><br><span class="line">        mov     z, ax</span><br><span class="line"></span><br><span class="line">        max3    x, y, z</span><br><span class="line"></span><br><span class="line">        ; 将结果转换为字符串</span><br><span class="line">        push    ax</span><br><span class="line">        lea     ax, result</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr     numberToStr</span><br><span class="line">        add     sp, 4                       ; 平衡堆栈</span><br><span class="line"></span><br><span class="line">        ; 显示结果提示信息</span><br><span class="line">        lea     dx, rMsg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; 显示结果</span><br><span class="line">        lea     dx, result</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; Exit</span><br><span class="line">        mov     ax, 4c00H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        ; 字符串转数值的通用过程</span><br><span class="line">        ; 入口参数：调用前按顺序压入字符串首地址，字符个数</span><br><span class="line">        ; 出口参数：转换结果保存在 AX 中</span><br><span class="line">strToNumber proc far</span><br><span class="line">        push    bp</span><br><span class="line">        mov     bp, sp</span><br><span class="line"></span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line">        push    dx</span><br><span class="line">        push    si</span><br><span class="line">        ; ax 不需要压入</span><br><span class="line"></span><br><span class="line">        mov     cx, [bp + 6]    ; 字符个数</span><br><span class="line">        mov     si, [bp + 8]    ; 字符串首地址</span><br><span class="line">        mov     ch, 0</span><br><span class="line">        ; dec     cl</span><br><span class="line"></span><br><span class="line">        ; 打印该字符串</span><br><span class="line">        ; mov     dx, si</span><br><span class="line">        ; mov     ah, 09H</span><br><span class="line">        ; int     21H</span><br><span class="line">        ; call    newLine</span><br><span class="line"></span><br><span class="line">        ; 显示字符串位数</span><br><span class="line">        ; mov     dl, cl</span><br><span class="line">        ; mov     ah, 02H</span><br><span class="line">        ; adc     dl, &#x27;0&#x27;</span><br><span class="line">        ; int     21H</span><br><span class="line">        ; call    newLine</span><br><span class="line"></span><br><span class="line">        xor     ax, ax      ; 将 ax 清零，用于保存转换结果</span><br><span class="line">        xor     dx, dx      ; dx 用于暂存每一位字符</span><br><span class="line">        xor     bx, bx      ; bx 用于存放乘数 10</span><br><span class="line">        mov     bl, 0aH</span><br><span class="line"></span><br><span class="line">    convertNum:</span><br><span class="line">        mul     bx          ; 将 ax 乘以 10</span><br><span class="line">        mov     dl, [si]</span><br><span class="line">        sub     dl, &#x27;0&#x27;     ; dh 为 0</span><br><span class="line">        add     ax, dx</span><br><span class="line">        inc     si</span><br><span class="line">        loop    convertNum</span><br><span class="line"></span><br><span class="line">        pop     si</span><br><span class="line">        pop     dx</span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     bp</span><br><span class="line">        ret</span><br><span class="line">strToNumber endp</span><br><span class="line"></span><br><span class="line">        ; 将数值转换为字符串的通用方法</span><br><span class="line">        ; 入口参数： 按顺序压入数值、目的字符串首地址</span><br><span class="line">        ; 出口参数： 无</span><br><span class="line">numberToStr proc far</span><br><span class="line">        push    bp</span><br><span class="line">        mov     bp, sp</span><br><span class="line"></span><br><span class="line">        push    ax</span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line">        push    dx</span><br><span class="line">        push    si</span><br><span class="line"></span><br><span class="line">        mov     ax, [bp + 8]    ; 取出数值</span><br><span class="line">        mov     si, [bp + 6]    ; 取出目的地址</span><br><span class="line">        mov     bx, 0aH         ; 用于保存 10</span><br><span class="line"></span><br><span class="line">        mov     dx, ax          ; 保存 ax</span><br><span class="line">        xor     cx, cx          ; 用于保存字符串的长度</span><br><span class="line">    getLength:</span><br><span class="line">        inc     cx</span><br><span class="line">        div     bl</span><br><span class="line">        xor     ah, ah</span><br><span class="line">        cmp     ax, 0</span><br><span class="line">        jnz     getLength</span><br><span class="line"></span><br><span class="line">        mov     ax, dx          ; 恢复ax</span><br><span class="line"></span><br><span class="line">        dec     cx</span><br><span class="line">        add     si, cx          ; 将 si 指向字符串的末尾</span><br><span class="line"></span><br><span class="line">    convertStr:</span><br><span class="line">        xor     dx, dx</span><br><span class="line">        div     bx              ; dx.ax / bx  余数在 dx， 商在 ax</span><br><span class="line">        add     dx, &#x27;0&#x27;</span><br><span class="line">        mov     [si], dl</span><br><span class="line">        dec     si</span><br><span class="line">        cmp     ax, 0</span><br><span class="line">        jnz     convertStr</span><br><span class="line">        </span><br><span class="line">        pop     si</span><br><span class="line">        pop     dx</span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     ax</span><br><span class="line">        pop     bp</span><br><span class="line">        ret</span><br><span class="line">numberToStr endp</span><br><span class="line"></span><br><span class="line">        ; 换行的通用过程</span><br><span class="line">newLine proc</span><br><span class="line">        push    ax</span><br><span class="line">        push    dx</span><br><span class="line"></span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        pop     dx</span><br><span class="line">        pop     ax</span><br><span class="line">        ret</span><br><span class="line">newLine endp</span><br><span class="line"></span><br><span class="line">code    ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h3 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h3><p>挂接 1CH 中断，正计时 90 秒后退出。要求屏幕显示 0 ~ 89 的秒数。</p>
<div>
            <div class="fold_hider">
              <div class="close hider_title">
              折叠/展开代码
              </div>
            </div>
            <div class="fold">
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; timer.asm</span><br><span class="line"></span><br><span class="line">stack   segment stack</span><br><span class="line">        db 1024 dup(?)</span><br><span class="line">stack   ends</span><br><span class="line"></span><br><span class="line">data    segment</span><br><span class="line">        oldInt  dw  0, 0</span><br><span class="line">        timer   dw  0</span><br><span class="line">        count   dw  0</span><br><span class="line">        addr    equ     1cH * 4     ; 1cH 号中断向量的地址</span><br><span class="line">        msg     db  20 dup(&#x27;$&#x27;)</span><br><span class="line">data    ends</span><br><span class="line"></span><br><span class="line">code    segment &#x27;code&#x27;</span><br><span class="line">        assume cs:code, ds:data</span><br><span class="line">start:</span><br><span class="line">        ; Init ds, es</span><br><span class="line">        mov     ax, data</span><br><span class="line">        mov     ds, ax</span><br><span class="line">        mov     ax, 0</span><br><span class="line">        mov     es, ax</span><br><span class="line"></span><br><span class="line">        ; 保存原中断</span><br><span class="line">        mov     ax, es:[addr]</span><br><span class="line">        mov     oldInt[0], ax</span><br><span class="line">        mov     ax, es:[addr + 2]</span><br><span class="line">        mov     oldInt[2], ax</span><br><span class="line"></span><br><span class="line">        ; 设置新中断</span><br><span class="line">        mov     word ptr   es:[addr], offset printTime</span><br><span class="line">        mov     word ptr   es:[addr + 2], seg printTime</span><br><span class="line"></span><br><span class="line">        mov     dl, &#x27;0&#x27;             ; 由于我写的数值转字符串不能正确处理数值 0 </span><br><span class="line">        mov     ah, 02H             ; 在这里先直接显示 0</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine</span><br><span class="line">again:</span><br><span class="line">        ; 比较输出次数</span><br><span class="line">        cmp     timer, 89</span><br><span class="line">        jae     exit</span><br><span class="line">        jmp     again</span><br><span class="line">exit:</span><br><span class="line">        ; 恢复原中断</span><br><span class="line">        mov     ax, oldInt[0]</span><br><span class="line">        mov     es:[addr], ax</span><br><span class="line">        mov     ax, oldInt[2]</span><br><span class="line">        mov     es:[addr + 2], ax</span><br><span class="line"></span><br><span class="line">        ; Exit</span><br><span class="line">        mov     ax, 4c00H</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">printTime     proc    far</span><br><span class="line">        push    ax</span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line">        push    dx</span><br><span class="line"></span><br><span class="line">        ; 开中断</span><br><span class="line">        sti</span><br><span class="line"></span><br><span class="line">        inc     count</span><br><span class="line">        cmp     count, 20  ; 比较被调用次数，若小于，则还没到 1 s</span><br><span class="line">        jb      exitFlag</span><br><span class="line">        inc     timer   </span><br><span class="line">        mov     count, 0        ; 将计次清零</span><br><span class="line"></span><br><span class="line">        ; 显示计时器中的数值</span><br><span class="line">        mov     ax, timer       ; 将数值转换成字符串</span><br><span class="line">        push    ax</span><br><span class="line">        lea     ax, msg</span><br><span class="line">        push    ax</span><br><span class="line">        call    far ptr numberToStr</span><br><span class="line">        add     sp, 4           ; 平衡堆栈</span><br><span class="line">        lea     dx, msg</span><br><span class="line">        mov     ah, 09H</span><br><span class="line">        int     21H</span><br><span class="line">        call    newLine         ; 换行</span><br><span class="line"></span><br><span class="line">    exitFlag:</span><br><span class="line">        pushf</span><br><span class="line">        call dword ptr oldInt   ; 调用原中断，形成中断链</span><br><span class="line">        pop     dx</span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     ax</span><br><span class="line">        iret</span><br><span class="line">printTime endp</span><br><span class="line"></span><br><span class="line">        ; 将数值转换为字符串的通用方法</span><br><span class="line">        ; 入口参数： 按顺序压入数值、目的字符串首地址</span><br><span class="line">        ; 出口参数： 无</span><br><span class="line">numberToStr proc far</span><br><span class="line">        push    bp</span><br><span class="line">        mov     bp, sp</span><br><span class="line"></span><br><span class="line">        push    ax</span><br><span class="line">        push    bx</span><br><span class="line">        push    cx</span><br><span class="line">        push    dx</span><br><span class="line">        push    si</span><br><span class="line"></span><br><span class="line">        mov     ax, [bp + 8]    ; 取出数值</span><br><span class="line">        mov     si, [bp + 6]    ; 取出目的地址</span><br><span class="line">        mov     bx, 0aH         ; 用于保存 10</span><br><span class="line"></span><br><span class="line">        mov     dx, ax          ; 保存 ax</span><br><span class="line">        xor     cx, cx          ; 用于保存字符串的长度</span><br><span class="line">    getLength:</span><br><span class="line">        inc     cx</span><br><span class="line">        div     bl</span><br><span class="line">        xor     ah, ah</span><br><span class="line">        cmp     ax, 0</span><br><span class="line">        jnz     getLength</span><br><span class="line"></span><br><span class="line">        mov     ax, dx          ; 恢复ax</span><br><span class="line"></span><br><span class="line">        dec     cx</span><br><span class="line">        add     si, cx          ; 将 si 指向字符串的末尾</span><br><span class="line"></span><br><span class="line">    convertStr:</span><br><span class="line">        xor     dx, dx</span><br><span class="line">        div     bx              ; dx.ax / bx 余数在 dx， 商在 ax</span><br><span class="line">        add     dx, &#x27;0&#x27;</span><br><span class="line">        mov     [si], dl</span><br><span class="line">        dec     si</span><br><span class="line">        cmp     ax, 0</span><br><span class="line">        jnz     convertStr</span><br><span class="line">        </span><br><span class="line">        pop     si</span><br><span class="line">        pop     dx</span><br><span class="line">        pop     cx</span><br><span class="line">        pop     bx</span><br><span class="line">        pop     ax</span><br><span class="line">        pop     bp</span><br><span class="line">        ret</span><br><span class="line">numberToStr endp</span><br><span class="line"></span><br><span class="line">        ; 换行的通用过程</span><br><span class="line">newLine proc</span><br><span class="line">        push    ax</span><br><span class="line">        push    dx</span><br><span class="line"></span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0dH</span><br><span class="line">        int     21H</span><br><span class="line">        mov     ah, 02H</span><br><span class="line">        mov     dl, 0aH</span><br><span class="line">        int     21H</span><br><span class="line"></span><br><span class="line">        pop     dx</span><br><span class="line">        pop     ax</span><br><span class="line">        ret</span><br><span class="line">newLine endp</span><br><span class="line"></span><br><span class="line">code    ends</span><br><span class="line">end     start</span><br></pre></td></tr></table></figure>

            </div>
          </div>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="任务一-1"><a href="#任务一-1" class="headerlink" title="任务一"></a>任务一</h3><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-03/task-01/result-01.png" alt="运行结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-03/task-01/result-02.png" alt="运行结果"></p>
<h3 id="任务二-1"><a href="#任务二-1" class="headerlink" title="任务二"></a>任务二</h3><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-03/task-02/result-01.png" alt="运行结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-03/task-02/result-02.png" alt="运行结果"></p>
<h3 id="任务三-1"><a href="#任务三-1" class="headerlink" title="任务三"></a>任务三</h3><p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-03/task-03/result-01.png" alt="运行结果"></p>
<p><img src="https://blog-xuewen-me.oss-cn-shanghai.aliyuncs.com/xuewen/blog/masm/experiment-03/task-03/result-02.png" alt="运行结果"></p>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次实验第一题主要在于学会编写子程序的格式、向子程序传递参数的方法。子程序分为近调用和远调用，本次实验中，用于换行的子程序不需要参数，我编写为近调用；其他的子程序都需要传递参数，我编写为远调用，并且需要调用者来平衡堆栈。</p>
<p>第二题主要为编写宏，宏的编写比子程序要简单一些，尤其是传递参数时，并且宏中还可以嵌套宏。在编译时，编译器会帮我们把宏进行展开。</p>
<p>编写两道题的代码时，共同的难点就是如何处理数字的输入和输出，这涉及到数值和对应字符串的转换，我编写了两个通用过程来处理数值和字符串的相互转换。</p>
<p>第三题主要为中断的使用。一般挂接中断时，分为以下几个步骤：</p>
<ol>
<li>保存原中断程序地址</li>
<li>挂接自己的中断</li>
<li>在自己的中断程序中，调用原中断，形成中断链</li>
<li>退出时，恢复原中断链</li>
</ol>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
</search>
